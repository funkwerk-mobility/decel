{
  "active_files": [
    "README.md",
    "dub.sdl",
    "source/decel/context.d",
    "source/decel/value.d",
    "source/decel/eval.d",
    "TODO.md",
    "source/decel/lexer.d",
    "dscanner.ini",
    "COMPATIBILITY.md",
    "Makefile",
    "source/decel/package.d"
  ],
  "request_log_entries": [
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335405227.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335405227.json",
      "timestamp": 1771335405.230151,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.320475,
      "generation_id": "gen-1771335405-R5WdJMhvMA6xUzJ9WGHY"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335412104.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335412104.json",
      "timestamp": 1771335412.1052802,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.0977835,
      "generation_id": "gen-1771335412-9N7vJk2IEr8oaNwVlDtx"
    },
    {
      "request_file": "/tmp/forge_debug/request_1771335455066.json",
      "response_file": "/tmp/forge_debug/response_1771335455066.json",
      "timestamp": 1771335455.0662158,
      "model": "anthropic/claude-haiku-4.5",
      "streaming": false,
      "actual_cost": 0.000171,
      "generation_id": "gen-1771335455-bZRjfhG0GoeUalLw1b9m"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335523477.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335523477.json",
      "timestamp": 1771335523.4788144,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.04903725,
      "generation_id": "gen-1771335523-g3460dikf0M1CwJ4rYAK"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335529742.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335529742.json",
      "timestamp": 1771335529.7437544,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.42509875,
      "generation_id": "gen-1771335530-tDnPUQwa0x1RrtqeV3N7"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335572297.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335572297.json",
      "timestamp": 1771335572.2998197,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.5764355,
      "generation_id": "gen-1771335572-tucyMZKhvqxtRPB4vRgF"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335590469.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335590469.json",
      "timestamp": 1771335590.4707553,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.36876625,
      "generation_id": "gen-1771335590-yqy5m1g529lOc7uYHvzd"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335649482.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335649482.json",
      "timestamp": 1771335649.483749,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.06694275,
      "generation_id": "gen-1771335649-OHihE1o0tM1TfuIm1AAq"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335674126.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335674126.json",
      "timestamp": 1771335674.1274104,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.06731775,
      "generation_id": "gen-1771335674-K1KsovVLp09ggHHixgPL"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335693208.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335693208.json",
      "timestamp": 1771335693.2100234,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.0478465,
      "generation_id": "gen-1771335693-eMj1t5FbkjPxcwkP5ySe"
    },
    {
      "request_file": "/tmp/forge_debug/request_stream_1771335702743.json",
      "response_file": "/tmp/forge_debug/response_stream_1771335702743.json",
      "timestamp": 1771335702.744576,
      "model": "anthropic/claude-opus-4.6",
      "streaming": true,
      "actual_cost": 0.33930925,
      "generation_id": "gen-1771335703-47QHhJZvipPDITys5hdv"
    }
  ],
  "messages": [
    {
      "role": "system",
      "content": "\u2705 Generated summaries for 18 files",
      "_ui_only": true
    },
    {
      "role": "user",
      "content": "Hi, can you make sure that decel.Value has a sensible toString (with unittests)?"
    },
    {
      "role": "assistant",
      "content": "\n\nLooking at the `Value` struct in `source/decel/value.d`, it doesn't have a `toString` method. Let me add one that produces sensible string representations for all value types, along with unit tests.",
      "tool_calls": [
        {
          "function": {
            "arguments": "{\"pattern\": \"formatISO8601Duration|formatRFC3339\", \"file\": \"source/decel/eval.d\", \"max_matches\": 4}",
            "name": "grep_context"
          },
          "id": "toolu_vrtx_01TaUfYSrE1crMEr9iLxdAGN",
          "type": "function"
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "toolu_vrtx_01TaUfYSrE1crMEr9iLxdAGN",
      "content": "{\"message\": \"Found 4 matches\", \"output\": \"\\u2500\\u2500 source/decel/eval.d:1060 \\u2500\\u2500\\n    1057 |         return Value(b.get ? \\\"true\\\" : \\\"false\\\");\\n    1058 |     auto dur = tryGet!Duration(v);\\n    1059 |     if (!dur.isNull)\\n>>> 1060 |         return Value(formatISO8601Duration(dur.get));\\n    1061 |     auto ts = tryGet!SysTime(v);\\n    1062 |     if (!ts.isNull)\\n    1063 |         return Value(formatRFC3339(ts.get));\\n\\n\\u2500\\u2500 source/decel/eval.d:1063 \\u2500\\u2500\\n    1060 |         return Value(formatISO8601Duration(dur.get));\\n    1061 |     auto ts = tryGet!SysTime(v);\\n    1062 |     if (!ts.isNull)\\n>>> 1063 |         return Value(formatRFC3339(ts.get));\\n    1064 |     return Value.err(\\\"cannot convert \\\" ~ typeName(v) ~ \\\" to string\\\");\\n    1065 | }\\n    1066 | \\n\\n\\u2500\\u2500 source/decel/eval.d:1735 \\u2500\\u2500\\n    1732 | }\\n    1733 | \\n    1734 | /// Format a Duration as an ISO 8601 duration string (e.g., \\\"PT1H30M15S\\\").\\n>>> 1735 | private string formatISO8601Duration(Duration d)\\n    1736 | {\\n    1737 |     import std.format : format;\\n    1738 | \\n\\n\\u2500\\u2500 source/decel/eval.d:1761 \\u2500\\u2500\\n    1758 | }\\n    1759 | \\n    1760 | /// Format a SysTime as an RFC 3339 timestamp string.\\n>>> 1761 | private string formatRFC3339(SysTime st)\\n    1762 | {\\n    1763 |     import std.format : format;\\n    1764 | \", \"side_effects\": [\"ephemeral_result\"], \"success\": true, \"total_matches\": 4}",
      "_skip_display": true
    },
    {
      "role": "system",
      "content": "\ud83d\udd27 **Tool call:** `grep_context`\n```json\n{\n  \"file\": \"source/decel/eval.d\",\n  \"max_matches\": 4,\n  \"pattern\": \"formatISO8601Duration|formatRFC3339\"\n}\n```\n**Result:**\n```json\n{\n  \"message\": \"Found 4 matches\",\n  \"output\": \"\\u2500\\u2500 source/decel/eval.d:1060 \\u2500\\u2500\\n    1057 |         return Value(b.get ? \\\"true\\\" : \\\"false\\\");\\n    1058 |     auto dur = tryGet!Duration(v);\\n    1059 |     if (!dur.isNull)\\n>>> 1060 |         return Value(formatISO8601Duration(dur.get));\\n    1061 |     auto ts = tryGet!SysTime(v);\\n    1062 |     if (!ts.isNull)\\n    1063 |         return Value(formatRFC3339(ts.get));\\n\\n\\u2500\\u2500 source/decel/eval.d:1063 \\u2500\\u2500\\n    1060 |         return Value(formatISO8601Duration(dur.get));\\n    1061 |     auto ts = tryGet!SysTime(v);\\n    1062 |     if (!ts.isNull)\\n>>> 1063 |         return Value(formatRFC3339(ts.get));\\n    1064 |     return Value.err(\\\"cannot convert \\\" ~ typeName(v) ~ \\\" to string\\\");\\n    1065 | }\\n    1066 | \\n\\n\\u2500\\u2500 source/decel/eval.d:1735 \\u2500\\u2500\\n    1732 | }\\n    1733 | \\n    1734 | /// Format a Duration as an ISO 8601 duration string (e.g., \\\"PT1H30M15S\\\").\\n>>> 1735 | private string formatISO8601Duration(Duration d)\\n    1736 | {\\n    1737 |     import std.format : format;\\n    1738 | \\n\\n\\u2500\\u2500 source/decel/eval.d:1761 \\u2500\\u2500\\n    1758 | }\\n    1759 | \\n    1760 | /// Format a SysTime as an RFC 3339 timestamp string.\\n>>> 1761 | private string formatRFC3339(SysTime st)\\n    1762 | {\\n    1763 |     import std.format : format;\\n    1764 | \",\n  \"side_effects\": [\n    \"ephemeral_result\"\n  ],\n  \"success\": true,\n  \"total_matches\": 4\n}\n```",
      "_ui_only": true
    },
    {
      "role": "assistant",
      "content": "\n\nThe formatting helpers (`formatISO8601Duration`, `formatRFC3339`) are private to `eval.d`, so I'll implement `toString` directly in `value.d` with its own formatting logic. Let me add a comprehensive `toString` method.\n\n<edit file=\"source/decel/value.d\">\n<search>\n    /// Hash support (needed when opEquals is defined).\n</search>\n<replace>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        import std.format : format;\n        import std.conv : to;\n\n        auto self = cast(Value) this;\n        return self.inner.match!(\n            (ref typeof(null) _) => \"null\",\n            (ref bool b) => b ? \"true\" : \"false\",\n            (ref long i) => i.to!string,\n            (ref ulong u) => u.to!string ~ \"u\",\n            (ref double d) => d.to!string,\n            (ref string s) {\n                // Escape special characters for a readable repr\n                char[] buf;\n                buf ~= '\"';\n                foreach (c; s)\n                {\n                    switch (c)\n                    {\n                    case '\"':  buf ~= `\\\"`; break;\n                    case '\\\\': buf ~= `\\\\`; break;\n                    case '\\n': buf ~= `\\n`; break;\n                    case '\\r': buf ~= `\\r`; break;\n                    case '\\t': buf ~= `\\t`; break;\n                    default:   buf ~= c;    break;\n                    }\n                }\n                buf ~= '\"';\n                return cast(string) buf;\n            },\n            (ref immutable(ubyte)[] bytes) {\n                char[] buf;\n                buf ~= \"b\\\"\";\n                foreach (b; bytes)\n                    buf ~= format!\"%02x\"(b);\n                buf ~= '\"';\n                return cast(string) buf;\n            },\n            (ref List list) {\n                char[] buf;\n                buf ~= '[';\n                foreach (i; 0 .. list.length)\n                {\n                    if (i > 0) buf ~= \", \";\n                    buf ~= list.index(i).toString();\n                }\n                buf ~= ']';\n                return cast(string) buf;\n            },\n            (ref Value[string] map) {\n                char[] buf;\n                buf ~= '{';\n                bool first = true;\n                // Sort keys for deterministic output\n                auto keys = map.keys;\n                import std.algorithm : sort;\n                keys.sort();\n                foreach (k; keys)\n                {\n                    if (!first) buf ~= \", \";\n                    first = false;\n                    // Format key as quoted string\n                    buf ~= '\"';\n                    foreach (c; k)\n                    {\n                        switch (c)\n                        {\n                        case '\"':  buf ~= `\\\"`; break;\n                        case '\\\\': buf ~= `\\\\`; break;\n                        default:   buf ~= c;    break;\n                        }\n                    }\n                    buf ~= '\"';\n                    buf ~= \": \";\n                    buf ~= map[k].toString();\n                }\n                buf ~= '}';\n                return cast(string) buf;\n            },\n            (ref Entry _) => \"<entry>\",\n            (ref Duration d) {\n                long totalSecs = d.total!\"seconds\";\n                bool negative = totalSecs < 0;\n                if (negative) totalSecs = -totalSecs;\n                long rem = totalSecs;\n                long h = rem / 3600;\n                rem %= 3600;\n                long m = rem / 60;\n                long sec = rem % 60;\n                char[] buf;\n                if (negative) buf ~= '-';\n                buf ~= \"PT\";\n                if (h > 0) buf ~= format!\"%dH\"(h);\n                if (m > 0) buf ~= format!\"%dM\"(m);\n                if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n                return cast(string) buf;\n            },\n            (ref SysTime st) {\n                auto utc = st.toUTC();\n                return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n                    utc.year, cast(int) utc.month, utc.day,\n                    utc.hour, utc.minute, utc.second);\n            },\n            (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n\n    /// Hash support (needed when opEquals is defined).\n</replace>\n</edit>\n\nNow let me add unit tests at the end of the file:\n\n<edit file=\"source/decel/value.d\">\n<search>\n@(\"Value: deep equality\")\n</search>\n<replace>\n@(\"Value: toString basics\")\nunittest\n{\n    import dshould;\n\n    // Null\n    Value.null_().toString().should.be(\"null\");\n\n    // Booleans\n    value(true).toString().should.be(\"true\");\n    value(false).toString().should.be(\"false\");\n\n    // Integers\n    value(0L).toString().should.be(\"0\");\n    value(42L).toString().should.be(\"42\");\n    value(-7L).toString().should.be(\"-7\");\n\n    // Unsigned integers\n    value(42UL).toString().should.be(\"42u\");\n    value(0UL).toString().should.be(\"0u\");\n\n    // Doubles\n    value(3.14).toString().should.be(\"3.14\");\n    value(0.0).toString().should.be(\"0\");\n    value(-2.5).toString().should.be(\"-2.5\");\n\n    // Strings\n    value(\"hello\").toString().should.be(`\"hello\"`);\n    value(\"\").toString().should.be(`\"\"`);\n    value(\"with \\\"quotes\\\"\").toString().should.be(`\"with \\\"quotes\\\"\"`);\n    value(\"line\\nbreak\").toString().should.be(`\"line\\nbreak\"`);\n    value(\"tab\\there\").toString().should.be(`\"tab\\there\"`);\n\n    // Bytes\n    value(cast(immutable(ubyte)[])[0x48, 0x69]).toString().should.be(`b\"4869\"`);\n    value(cast(immutable(ubyte)[])[]).toString().should.be(`b\"\"`);\n\n    // Errors\n    Value.err(\"something broke\").toString().should.be(\"error: something broke\");\n}\n\n@(\"Value: toString collections\")\nunittest\n{\n    import dshould;\n\n    // Lists\n    value(cast(Value[])[]).toString().should.be(\"[]\");\n    value([value(1L), value(2L), value(3L)]).toString().should.be(\"[1, 2, 3]\");\n    value([value(\"a\"), value(\"b\")]).toString().should.be(`[\"a\", \"b\"]`);\n\n    // Nested lists\n    value([value([value(1L), value(2L)]), value([value(3L)])]).toString()\n        .should.be(\"[[1, 2], [3]]\");\n\n    // Maps (keys sorted alphabetically)\n    Value[string] m;\n    m[\"b\"] = value(2L);\n    m[\"a\"] = value(1L);\n    Value(m).toString().should.be(`{\"a\": 1, \"b\": 2}`);\n\n    // Empty map\n    Value[string] empty;\n    Value(empty).toString().should.be(\"{}\");\n}\n\n@(\"Value: toString duration and timestamp\")\nunittest\n{\n    import dshould;\n    import core.time : hours, minutes, seconds;\n    import std.datetime.systime : SysTime;\n    import std.datetime.date : DateTime;\n    import std.datetime.timezone : UTC;\n\n    // Durations\n    value(1.hours + 30.minutes).toString().should.be(\"PT1H30M\");\n    value(90.seconds).toString().should.be(\"PT1M30S\");\n    value(0.seconds).toString().should.be(\"PT0S\");\n    value(2.hours).toString().should.be(\"PT2H\");\n\n    // Timestamps\n    value(SysTime(DateTime(2023, 1, 15, 12, 30, 45), UTC())).toString()\n        .should.be(\"2023-01-15T12:30:45Z\");\n}\n\n@(\"Value: deep equality\")\n</replace>\n</edit>\n\n<run_tests/>\n<commit message=\"Add Value.toString() with human-readable formatting and tests\n\nImplements toString() on the Value struct that produces readable output\nfor all CEL types:\n- null, bool, int, uint (with 'u' suffix), double\n- Strings with escape sequences (quotes, newlines, tabs, backslashes)\n- Bytes as hex (b\\\"4869\\\")\n- Lists as [1, 2, 3]\n- Maps with sorted keys as {\\\"a\\\": 1, \\\"b\\\": 2}\n- Durations as ISO 8601 (PT1H30M)\n- Timestamps as RFC 3339 (2023-01-15T12:30:45Z)\n- Entries as <entry>\n- Errors as 'error: message'\n\nIncludes unit tests covering all types, collections, nesting, and\nedge cases (empty strings, empty collections, negative values).\"/>\n\nDone! I've added a `toString()` method to `Value` that produces human-readable output for all CEL types:\n\n| Type | Example output |\n|------|---------------|\n| `null` | `null` |\n| `bool` | `true`, `false` |\n| `int` | `42`, `-7` |\n| `uint` | `42u` |\n| `double` | `3.14` |\n| `string` | `\"hello\"`, `\"with \\\"quotes\\\"\"` |\n| `bytes` | `b\"4869\"` |\n| `list` | `[1, 2, 3]` |\n| `map` | `{\"a\": 1, \"b\": 2}` (keys sorted) |\n| `duration` | `PT1H30M` |\n| `timestamp` | `2023-01-15T12:30:45Z` |\n| `entry` | `<entry>` |\n| `error` | `error: something broke` |\n\nThe method handles escaping in strings (`\\\"`, `\\\\`, `\\n`, `\\r`, `\\t`), sorts map keys for deterministic output, and formats nested collections recursively. Three test blocks cover basics, collections/nesting, and duration/timestamp formatting.",
      "_inline_results": [
        {
          "message": "Replaced in source/decel/value.d",
          "modified_files": [
            "source/decel/value.d"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "message": "Replaced in source/decel/value.d",
          "modified_files": [
            "source/decel/value.d"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "display_output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:37:30.900949768 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:37:30.909523825 +0100\n@@ -214,106 +214,119 @@\n         import std.conv : to;\n \n         auto self = cast(Value) this;\n-        return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => i.to!string,\n-            (ref ulong u) => u.to!string ~ \"u\",\n-            (ref double d) => d.to!string,\n-            (ref string s) {\n-                // Escape special characters for a readable repr\n-                char[] buf;\n-                buf ~= '\"';\n-                foreach (c; s)\n+        return self.inner.match!((ref typeof(null) _) => \"null\", (ref bool b) => b\n+                ? \"true\" : \"false\", (ref long i) => i.to!string,\n+                (ref ulong u) => u.to!string ~ \"u\", (ref double d) => d.to!string, (ref string s) {\n+            // Escape special characters for a readable repr\n+            char[] buf;\n+            buf ~= '\"';\n+            foreach (c; s)\n+            {\n+                switch (c)\n                 {\n-                    switch (c)\n-                    {\n-                    case '\"':  buf ~= `\\\"`; break;\n-                    case '\\\\': buf ~= `\\\\`; break;\n-                    case '\\n': buf ~= `\\n`; break;\n-                    case '\\r': buf ~= `\\r`; break;\n-                    case '\\t': buf ~= `\\t`; break;\n-                    default:   buf ~= c;    break;\n-                    }\n+                case '\"':\n+                    buf ~= `\\\"`;\n+                    break;\n+                case '\\\\':\n+                    buf ~= `\\\\`;\n+                    break;\n+                case '\\n':\n+                    buf ~= `\\n`;\n+                    break;\n+                case '\\r':\n+                    buf ~= `\\r`;\n+                    break;\n+                case '\\t':\n+                    buf ~= `\\t`;\n+                    break;\n+                default:\n+                    buf ~= c;\n+                    break;\n                 }\n+            }\n+            buf ~= '\"';\n+            return cast(string) buf;\n+        }, (ref immutable(ubyte)[] bytes) {\n+            char[] buf;\n+            buf ~= \"b\\\"\";\n+            foreach (b; bytes)\n+                buf ~= format!\"%02x\"(b);\n+            buf ~= '\"';\n+            return cast(string) buf;\n+        }, (ref List list) {\n+            char[] buf;\n+            buf ~= '[';\n+            foreach (i; 0 .. list.length)\n+            {\n+                if (i > 0)\n+                    buf ~= \", \";\n+                buf ~= list.index(i).toString();\n+            }\n+            buf ~= ']';\n+            return cast(string) buf;\n+        }, (ref Value[string] map) {\n+            char[] buf;\n+            buf ~= '{';\n+            bool first = true;\n+            // Sort keys for deterministic output\n+            auto keys = map.keys;\n+            import std.algorithm : sort;\n+\n+            keys.sort();\n+            foreach (k; keys)\n+            {\n+                if (!first)\n+                    buf ~= \", \";\n+                first = false;\n+                // Format key as quoted string\n                 buf ~= '\"';\n-                return cast(string) buf;\n-            },\n-            (ref immutable(ubyte)[] bytes) {\n-                char[] buf;\n-                buf ~= \"b\\\"\";\n-                foreach (b; bytes)\n-                    buf ~= format!\"%02x\"(b);\n-                buf ~= '\"';\n-                return cast(string) buf;\n-            },\n-            (ref List list) {\n-                char[] buf;\n-                buf ~= '[';\n-                foreach (i; 0 .. list.length)\n-                {\n-                    if (i > 0) buf ~= \", \";\n-                    buf ~= list.index(i).toString();\n-                }\n-                buf ~= ']';\n-                return cast(string) buf;\n-            },\n-            (ref Value[string] map) {\n-                char[] buf;\n-                buf ~= '{';\n-                bool first = true;\n-                // Sort keys for deterministic output\n-                auto keys = map.keys;\n-                import std.algorithm : sort;\n-                keys.sort();\n-                foreach (k; keys)\n+                foreach (c; k)\n                 {\n-                    if (!first) buf ~= \", \";\n-                    first = false;\n-                    // Format key as quoted string\n-                    buf ~= '\"';\n-                    foreach (c; k)\n+                    switch (c)\n                     {\n-                        switch (c)\n-                        {\n-                        case '\"':  buf ~= `\\\"`; break;\n-                        case '\\\\': buf ~= `\\\\`; break;\n-                        default:   buf ~= c;    break;\n-                        }\n+                    case '\"':\n+                        buf ~= `\\\"`;\n+                        break;\n+                    case '\\\\':\n+                        buf ~= `\\\\`;\n+                        break;\n+                    default:\n+                        buf ~= c;\n+                        break;\n                     }\n-                    buf ~= '\"';\n-                    buf ~= \": \";\n-                    buf ~= map[k].toString();\n                 }\n-                buf ~= '}';\n-                return cast(string) buf;\n-            },\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) {\n-                long totalSecs = d.total!\"seconds\";\n-                bool negative = totalSecs < 0;\n-                if (negative) totalSecs = -totalSecs;\n-                long rem = totalSecs;\n-                long h = rem / 3600;\n-                rem %= 3600;\n-                long m = rem / 60;\n-                long sec = rem % 60;\n-                char[] buf;\n-                if (negative) buf ~= '-';\n-                buf ~= \"PT\";\n-                if (h > 0) buf ~= format!\"%dH\"(h);\n-                if (m > 0) buf ~= format!\"%dM\"(m);\n-                if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n-                return cast(string) buf;\n-            },\n-            (ref SysTime st) {\n-                auto utc = st.toUTC();\n-                return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n-                    utc.year, cast(int) utc.month, utc.day,\n-                    utc.hour, utc.minute, utc.second);\n-            },\n-            (ref Err e) => \"error: \" ~ e.message,\n-        );\n+                buf ~= '\"';\n+                buf ~= \": \";\n+                buf ~= map[k].toString();\n+            }\n+            buf ~= '}';\n+            return cast(string) buf;\n+        }, (ref Entry _) => \"<entry>\", (ref Duration d) {\n+            long totalSecs = d.total!\"seconds\";\n+            bool negative = totalSecs < 0;\n+            if (negative)\n+                totalSecs = -totalSecs;\n+            long rem = totalSecs;\n+            long h = rem / 3600;\n+            rem %= 3600;\n+            long m = rem / 60;\n+            long sec = rem % 60;\n+            char[] buf;\n+            if (negative)\n+                buf ~= '-';\n+            buf ~= \"PT\";\n+            if (h > 0)\n+                buf ~= format!\"%dH\"(h);\n+            if (m > 0)\n+                buf ~= format!\"%dM\"(m);\n+            if (sec > 0 || (h == 0 && m == 0))\n+                buf ~= format!\"%dS\"(sec);\n+            return cast(string) buf;\n+        }, (ref SysTime st) {\n+            auto utc = st.toUTC();\n+            return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(utc.year,\n+                cast(int) utc.month, utc.day, utc.hour, utc.minute, utc.second);\n+        }, (ref Err e) => \"error: \" ~ e.message,);\n     }\n \n     /// Hash support (needed when opEquals is defined).\ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: list.map() comprehension:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: string methods:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: string operations:\ndecel.lexer.Lexer: string literals:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.lexer.Lexer: empty input:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: single = token:\ndecel.eval.Eval: lazy List subclass:\ndecel.value.Value: toString duration and timestamp:\ndecel.eval.Eval: null semantics:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: numeric literals:\ndecel.value.Value: deep equality:\ndecel.value.Value: toString basics:\ndecel.value.Value: toString collections:\ndecel.eval.Eval: timestamp constructor and methods:\n\nTime taken: 2 ms, 577 \u03bcs, and 7 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "modified_files": [
            "source/decel/value.d"
          ],
          "output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:37:30.900949768 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:37:30.909523825 +0100\n@@ -214,106 +214,119 @@\n         import std.conv : to;\n \n         auto self = cast(Value) this;\n-        return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => i.to!string,\n-            (ref ulong u) => u.to!string ~ \"u\",\n-            (ref double d) => d.to!string,\n-            (ref string s) {\n-                // Escape special characters for a readable repr\n-                char[] buf;\n-                buf ~= '\"';\n-                foreach (c; s)\n+        return self.inner.match!((ref typeof(null) _) => \"null\", (ref bool b) => b\n+                ? \"true\" : \"false\", (ref long i) => i.to!string,\n+                (ref ulong u) => u.to!string ~ \"u\", (ref double d) => d.to!string, (ref string s) {\n+            // Escape special characters for a readable repr\n+            char[] buf;\n+            buf ~= '\"';\n+            foreach (c; s)\n+            {\n+                switch (c)\n                 {\n-                    switch (c)\n-                    {\n-                    case '\"':  buf ~= `\\\"`; break;\n-                    case '\\\\': buf ~= `\\\\`; break;\n-                    case '\\n': buf ~= `\\n`; break;\n-                    case '\\r': buf ~= `\\r`; break;\n-                    case '\\t': buf ~= `\\t`; break;\n-                    default:   buf ~= c;    break;\n-                    }\n+                case '\"':\n+                    buf ~= `\\\"`;\n+                    break;\n+                case '\\\\':\n+                    buf ~= `\\\\`;\n+                    break;\n+                case '\\n':\n+                    buf ~= `\\n`;\n+                    break;\n+                case '\\r':\n+                    buf ~= `\\r`;\n+                    break;\n+                case '\\t':\n+                    buf ~= `\\t`;\n+                    break;\n+                default:\n+                    buf ~= c;\n+                    break;\n                 }\n+            }\n+            buf ~= '\"';\n+            return cast(string) buf;\n+        }, (ref immutable(ubyte)[] bytes) {\n+            char[] buf;\n+            buf ~= \"b\\\"\";\n+            foreach (b; bytes)\n+                buf ~= format!\"%02x\"(b);\n+            buf ~= '\"';\n+            return cast(string) buf;\n+        }, (ref List list) {\n+            char[] buf;\n+            buf ~= '[';\n+            foreach (i; 0 .. list.length)\n+            {\n+                if (i > 0)\n+                    buf ~= \", \";\n+                buf ~= list.index(i).toString();\n+            }\n+            buf ~= ']';\n+            return cast(string) buf;\n+        }, (ref Value[string] map) {\n+            char[] buf;\n+            buf ~= '{';\n+            bool first = true;\n+            // Sort keys for deterministic output\n+            auto keys = map.keys;\n+            import std.algorithm : sort;\n+\n+            keys.sort();\n+            foreach (k; keys)\n+            {\n+                if (!first)\n+                    buf ~= \", \";\n+                first = false;\n+                // Format key as quoted string\n                 buf ~= '\"';\n-                return cast(string) buf;\n-            },\n-            (ref immutable(ubyte)[] bytes) {\n-                char[] buf;\n-                buf ~= \"b\\\"\";\n-                foreach (b; bytes)\n-                    buf ~= format!\"%02x\"(b);\n-                buf ~= '\"';\n-                return cast(string) buf;\n-            },\n-            (ref List list) {\n-                char[] buf;\n-                buf ~= '[';\n-                foreach (i; 0 .. list.length)\n-                {\n-                    if (i > 0) buf ~= \", \";\n-                    buf ~= list.index(i).toString();\n-                }\n-                buf ~= ']';\n-                return cast(string) buf;\n-            },\n-            (ref Value[string] map) {\n-                char[] buf;\n-                buf ~= '{';\n-                bool first = true;\n-                // Sort keys for deterministic output\n-                auto keys = map.keys;\n-                import std.algorithm : sort;\n-                keys.sort();\n-                foreach (k; keys)\n+                foreach (c; k)\n                 {\n-                    if (!first) buf ~= \", \";\n-                    first = false;\n-                    // Format key as quoted string\n-                    buf ~= '\"';\n-                    foreach (c; k)\n+                    switch (c)\n                     {\n-                        switch (c)\n-                        {\n-                        case '\"':  buf ~= `\\\"`; break;\n-                        case '\\\\': buf ~= `\\\\`; break;\n-                        default:   buf ~= c;    break;\n-                        }\n+                    case '\"':\n+                        buf ~= `\\\"`;\n+                        break;\n+                    case '\\\\':\n+                        buf ~= `\\\\`;\n+                        break;\n+                    default:\n+                        buf ~= c;\n+                        break;\n                     }\n-                    buf ~= '\"';\n-                    buf ~= \": \";\n-                    buf ~= map[k].toString();\n                 }\n-                buf ~= '}';\n-                return cast(string) buf;\n-            },\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) {\n-                long totalSecs = d.total!\"seconds\";\n-                bool negative = totalSecs < 0;\n-                if (negative) totalSecs = -totalSecs;\n-                long rem = totalSecs;\n-                long h = rem / 3600;\n-                rem %= 3600;\n-                long m = rem / 60;\n-                long sec = rem % 60;\n-                char[] buf;\n-                if (negative) buf ~= '-';\n-                buf ~= \"PT\";\n-                if (h > 0) buf ~= format!\"%dH\"(h);\n-                if (m > 0) buf ~= format!\"%dM\"(m);\n-                if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n-                return cast(string) buf;\n-            },\n-            (ref SysTime st) {\n-                auto utc = st.toUTC();\n-                return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n-                    utc.year, cast(int) utc.month, utc.day,\n-                    utc.hour, utc.minute, utc.second);\n-            },\n-            (ref Err e) => \"error: \" ~ e.message,\n-        );\n+                buf ~= '\"';\n+                buf ~= \": \";\n+                buf ~= map[k].toString();\n+            }\n+            buf ~= '}';\n+            return cast(string) buf;\n+        }, (ref Entry _) => \"<entry>\", (ref Duration d) {\n+            long totalSecs = d.total!\"seconds\";\n+            bool negative = totalSecs < 0;\n+            if (negative)\n+                totalSecs = -totalSecs;\n+            long rem = totalSecs;\n+            long h = rem / 3600;\n+            rem %= 3600;\n+            long m = rem / 60;\n+            long sec = rem % 60;\n+            char[] buf;\n+            if (negative)\n+                buf ~= '-';\n+            buf ~= \"PT\";\n+            if (h > 0)\n+                buf ~= format!\"%dH\"(h);\n+            if (m > 0)\n+                buf ~= format!\"%dM\"(m);\n+            if (sec > 0 || (h == 0 && m == 0))\n+                buf ~= format!\"%dS\"(sec);\n+            return cast(string) buf;\n+        }, (ref SysTime st) {\n+            auto utc = st.toUTC();\n+            return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(utc.year,\n+                cast(int) utc.month, utc.day, utc.hour, utc.minute, utc.second);\n+        }, (ref Err e) => \"error: \" ~ e.message,);\n     }\n \n     /// Hash support (needed when opEquals is defined).\ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: list.map() comprehension:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: string methods:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: string operations:\ndecel.lexer.Lexer: string literals:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.lexer.Lexer: empty input:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: single = token:\ndecel.eval.Eval: lazy List subclass:\ndecel.value.Value: toString duration and timestamp:\ndecel.eval.Eval: null semantics:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: numeric literals:\ndecel.value.Value: deep equality:\ndecel.value.Value: toString basics:\ndecel.value.Value: toString collections:\ndecel.eval.Eval: timestamp constructor and methods:\n\nTime taken: 2 ms, 577 \u03bcs, and 7 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "passed": false,
          "side_effects": [
            "files_modified",
            "has_display_output"
          ],
          "success": true,
          "summary": "\u2713 Tests passed (make test)",
          "test_command": "make test"
        }
      ]
    },
    {
      "role": "system",
      "content": "\u2705 Changes committed: bc8e4fc9",
      "_ui_only": true
    },
    {
      "role": "user",
      "content": "Cheers! Ah, dfmt kinda made a hash of it... might be better to define a bunch of local functions for the formatters. Alternately, set --keep_line_breaks in the dfmt call."
    },
    {
      "role": "assistant",
      "content": "\n\nGood point! Let me refactor the `toString` to use local helper functions so dfmt doesn't mangle the lambda formatting, and also add `--keep_line_breaks` to the dfmt call in the Makefile.",
      "tool_calls": [
        {
          "function": {
            "arguments": "{\"add\": [\"source/decel/value.d\", \"Makefile\"]}",
            "name": "update_context"
          },
          "id": "toolu_vrtx_01DpPui7Zxp6m5QAw9rUZNV8",
          "type": "function"
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "toolu_vrtx_01DpPui7Zxp6m5QAw9rUZNV8",
      "content": "{\"action\": \"update_context\", \"add\": [\"source/decel/value.d\", \"Makefile\"], \"message\": \"Added 2 files, removed 0 files from context\", \"remove\": [], \"success\": true}",
      "_skip_display": true
    },
    {
      "role": "assistant",
      "content": "\n\nLooking at the current state of `toString` in `value.d`, dfmt has indeed mangled the nice lambda formatting into a mess with each `switch` case expanded vertically. I'll refactor it to use local helper functions, and also add `--keep_line_breaks` to the Makefile's dfmt call.\n\n<edit file=\"source/decel/value.d\">\n<search>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        import std.format : format;\n        import std.conv : to;\n\n        auto self = cast(Value) this;\n        return self.inner.match!((ref typeof(null) _) => \"null\", (ref bool b) => b\n                ? \"true\" : \"false\", (ref long i) => i.to!string,\n                (ref ulong u) => u.to!string ~ \"u\", (ref double d) => d.to!string, (ref string s) {\n            // Escape special characters for a readable repr\n            char[] buf;\n            buf ~= '\"';\n            foreach (c; s)\n            {\n                switch (c)\n                {\n                case '\"':\n                    buf ~= `\\\"`;\n                    break;\n                case '\\\\':\n                    buf ~= `\\\\`;\n                    break;\n                case '\\n':\n                    buf ~= `\\n`;\n                    break;\n                case '\\r':\n                    buf ~= `\\r`;\n                    break;\n                case '\\t':\n                    buf ~= `\\t`;\n                    break;\n                default:\n                    buf ~= c;\n                    break;\n                }\n            }\n            buf ~= '\"';\n            return cast(string) buf;\n        }, (ref immutable(ubyte)[] bytes) {\n            char[] buf;\n            buf ~= \"b\\\"\";\n            foreach (b; bytes)\n                buf ~= format!\"%02x\"(b);\n            buf ~= '\"';\n            return cast(string) buf;\n        }, (ref List list) {\n            char[] buf;\n            buf ~= '[';\n            foreach (i; 0 .. list.length)\n            {\n                if (i > 0)\n                    buf ~= \", \";\n                buf ~= list.index(i).toString();\n            }\n            buf ~= ']';\n            return cast(string) buf;\n        }, (ref Value[string] map) {\n            char[] buf;\n            buf ~= '{';\n            bool first = true;\n            // Sort keys for deterministic output\n            auto keys = map.keys;\n            import std.algorithm : sort;\n\n            keys.sort();\n            foreach (k; keys)\n            {\n                if (!first)\n                    buf ~= \", \";\n                first = false;\n                // Format key as quoted string\n                buf ~= '\"';\n                foreach (c; k)\n                {\n                    switch (c)\n                    {\n                    case '\"':\n                        buf ~= `\\\"`;\n                        break;\n                    case '\\\\':\n                        buf ~= `\\\\`;\n                        break;\n                    default:\n                        buf ~= c;\n                        break;\n                    }\n                }\n                buf ~= '\"';\n                buf ~= \": \";\n                buf ~= map[k].toString();\n            }\n            buf ~= '}';\n            return cast(string) buf;\n        }, (ref Entry _) => \"<entry>\", (ref Duration d) {\n            long totalSecs = d.total!\"seconds\";\n            bool negative = totalSecs < 0;\n            if (negative)\n                totalSecs = -totalSecs;\n            long rem = totalSecs;\n            long h = rem / 3600;\n            rem %= 3600;\n            long m = rem / 60;\n            long sec = rem % 60;\n            char[] buf;\n            if (negative)\n                buf ~= '-';\n            buf ~= \"PT\";\n            if (h > 0)\n                buf ~= format!\"%dH\"(h);\n            if (m > 0)\n                buf ~= format!\"%dM\"(m);\n            if (sec > 0 || (h == 0 && m == 0))\n                buf ~= format!\"%dS\"(sec);\n            return cast(string) buf;\n        }, (ref SysTime st) {\n            auto utc = st.toUTC();\n            return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(utc.year,\n                cast(int) utc.month, utc.day, utc.hour, utc.minute, utc.second);\n        }, (ref Err e) => \"error: \" ~ e.message,);\n    }\n</search>\n<replace>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        auto self = cast(Value) this;\n        return self.inner.match!(\n            (ref typeof(null) _) => \"null\",\n            (ref bool b) => b ? \"true\" : \"false\",\n            (ref long i) => fmtInt(i),\n            (ref ulong u) => fmtUint(u),\n            (ref double d) => fmtDouble(d),\n            (ref string s) => fmtString(s),\n            (ref immutable(ubyte)[] b) => fmtBytes(b),\n            (ref List l) => fmtList(l),\n            (ref Value[string] m) => fmtMap(m),\n            (ref Entry _) => \"<entry>\",\n            (ref Duration d) => fmtDuration(d),\n            (ref SysTime t) => fmtTimestamp(t),\n            (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n\n    /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n    /// the match table above as a clean, scannable list.\n    private static:\n\n    string fmtInt(long i)\n    {\n        import std.conv : to;\n        return i.to!string;\n    }\n\n    string fmtUint(ulong u)\n    {\n        import std.conv : to;\n        return u.to!string ~ \"u\";\n    }\n\n    string fmtDouble(double d)\n    {\n        import std.conv : to;\n        return d.to!string;\n    }\n\n    string fmtString(string s)\n    {\n        char[] buf;\n        buf ~= '\"';\n        foreach (c; s)\n        {\n            switch (c)\n            {\n                case '\"':  buf ~= `\\\"`; break;\n                case '\\\\': buf ~= `\\\\`; break;\n                case '\\n': buf ~= `\\n`; break;\n                case '\\r': buf ~= `\\r`; break;\n                case '\\t': buf ~= `\\t`; break;\n                default:   buf ~= c;    break;\n            }\n        }\n        buf ~= '\"';\n        return cast(string) buf;\n    }\n\n    string fmtBytes(immutable(ubyte)[] bytes)\n    {\n        import std.format : format;\n        char[] buf;\n        buf ~= \"b\\\"\";\n        foreach (b; bytes)\n            buf ~= format!\"%02x\"(b);\n        buf ~= '\"';\n        return cast(string) buf;\n    }\n\n    string fmtList(List list)\n    {\n        char[] buf;\n        buf ~= '[';\n        foreach (i; 0 .. list.length)\n        {\n            if (i > 0) buf ~= \", \";\n            buf ~= list.index(i).toString();\n        }\n        buf ~= ']';\n        return cast(string) buf;\n    }\n\n    string fmtMap(Value[string] map)\n    {\n        import std.algorithm : sort;\n        char[] buf;\n        buf ~= '{';\n        auto keys = map.keys;\n        keys.sort();\n        bool first = true;\n        foreach (k; keys)\n        {\n            if (!first) buf ~= \", \";\n            first = false;\n            buf ~= fmtString(k);\n            buf ~= \": \";\n            buf ~= map[k].toString();\n        }\n        buf ~= '}';\n        return cast(string) buf;\n    }\n\n    string fmtDuration(Duration d)\n    {\n        import std.format : format;\n        long totalSecs = d.total!\"seconds\";\n        bool negative = totalSecs < 0;\n        if (negative) totalSecs = -totalSecs;\n        long rem = totalSecs;\n        long h = rem / 3600;\n        rem %= 3600;\n        long m = rem / 60;\n        long sec = rem % 60;\n        char[] buf;\n        if (negative) buf ~= '-';\n        buf ~= \"PT\";\n        if (h > 0) buf ~= format!\"%dH\"(h);\n        if (m > 0) buf ~= format!\"%dM\"(m);\n        if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n        return cast(string) buf;\n    }\n\n    string fmtTimestamp(SysTime st)\n    {\n        import std.format : format;\n        auto utc = st.toUTC();\n        return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n            utc.year, cast(int) utc.month, utc.day,\n            utc.hour, utc.minute, utc.second);\n    }\n</replace>\n</edit>\n\nNow add `--keep_line_breaks` to the dfmt call in the Makefile:\n\n<edit file=\"Makefile\">\n<search>\n\t\t$(DFMT) < \"$$f\" | diff -u \"$$f\" - | sed \"s|--- $$f|--- a/$$f|;s|+++ -|+++ b/$$f|\" > /tmp/dfmt_diff 2>&1 || true; \\\n\t\tif [ -s /tmp/dfmt_diff ]; then \\\n\t\t\techo \"dfmt reformatted: $$f\"; \\\n\t\t\tcat /tmp/dfmt_diff; \\\n\t\t\t$(DFMT) -i \"$$f\"; \\\n</search>\n<replace>\n\t\t$(DFMT) --keep_line_breaks < \"$$f\" | diff -u \"$$f\" - | sed \"s|--- $$f|--- a/$$f|;s|+++ -|+++ b/$$f|\" > /tmp/dfmt_diff 2>&1 || true; \\\n\t\tif [ -s /tmp/dfmt_diff ]; then \\\n\t\t\techo \"dfmt reformatted: $$f\"; \\\n\t\t\tcat /tmp/dfmt_diff; \\\n\t\t\t$(DFMT) --keep_line_breaks -i \"$$f\"; \\\n</replace>\n</edit>\n\n<run_tests/>"
    },
    {
      "role": "user",
      "content": "\u274c `run_tests` failed:\n\ndfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:39:29.963397213 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:39:29.967758611 +0100\n@@ -1,584 +0,0 @@\n-/++\n- + CEL Value type \u2014 a tagged union of all CEL types.\n- +/\n-module decel.value;\n-\n-import core.time : Duration;\n-import std.datetime.systime : SysTime;\n-import std.sumtype;\n-import std.typecons : Nullable;\n-\n-import decel.exception : EvalException;\n-\n-/// Lazy value resolution. Subclass to provide deferred/lazy field access.\n-///\n-/// Override `asList()` to make this entry usable in list contexts\n-/// (comprehensions, `size()`, `in`, indexing). Override `asValue()` to\n-/// make it unwrap to a scalar in arithmetic/comparison contexts.\n-abstract class Entry\n-{\n-    /// Resolve a named field on this entry.\n-    Value resolve(string name);\n-\n-    /// If this entry can act as a list, return it. Default: null.\n-    List asList()\n-    {\n-        return null;\n-    }\n-\n-    /// If this entry has an underlying scalar value, return it. Default: null.\n-    import std.typecons : Nullable;\n-\n-    Nullable!Value asValue()\n-    {\n-        return Nullable!Value.init;\n-    }\n-\n-    /// Handle a method-call macro on this entry. Called when the evaluator\n-    /// sees `entry.name(...)`. The opening `(` has already been consumed.\n-    /// Parse arguments from the token range and consume the closing `)`.\n-    /// Return `Nullable!Value.init` to fall through to normal method dispatch.\n-    import decel.env : TokenRange, Env;\n-    import decel.context : Context;\n-\n-    Nullable!Value evalMacro(string, Value, ref TokenRange, const Env, Context)\n-    {\n-        return Nullable!Value.init;\n-    }\n-\n-    /// Called after an expression resolves to this Entry, before the\n-    /// evaluator checks for `.`, `[`, or binary operators. Peek at the\n-    /// upcoming tokens and parse a continuation if desired (e.g. `{...}`\n-    /// attribute filters). Return `Nullable!Value.init` to fall through\n-    /// to normal infix/postfix dispatch.\n-    Nullable!Value evalContinuation(Value, ref TokenRange, const Env, Context)\n-    {\n-        return Nullable!Value.init;\n-    }\n-}\n-\n-/// Abstract list \u2014 supports indexing and size without materializing.\n-/// Subclass to provide virtual array access over large datasets.\n-/// The built-in `ArrayList` wraps a `Value[]` for literal list values.\n-abstract class List\n-{\n-    /// Number of elements in the list.\n-    abstract size_t length();\n-\n-    /// Retrieve element at the given index (0-based).\n-    abstract Value index(size_t i);\n-}\n-\n-/// Concrete list backed by a `Value[]` array.\n-/// Used internally for list literals and list operations.\n-class ArrayList : List\n-{\n-    /// The underlying array storage.\n-    Value[] elements;\n-\n-    /// Construct from an existing array.\n-    this(Value[] elems)\n-    {\n-        elements = elems;\n-    }\n-\n-    override size_t length()\n-    {\n-        return elements.length;\n-    }\n-\n-    override Value index(size_t i)\n-    {\n-        return elements[i];\n-    }\n-}\n-\n-/// A CEL value: the runtime representation of any CEL expression result.\n-struct Value\n-{\n-    /// The set of types a CEL Value can hold.\n-    enum Type\n-    {\n-        null_,\n-        bool_,\n-        int_,\n-        uint_,\n-        double_,\n-        string_,\n-        bytes_,\n-        list,\n-        map,\n-        entry,\n-        duration,\n-        timestamp,\n-        err,\n-    }\n-\n-    alias Inner = SumType!(typeof(null), // null_\n-            bool, // bool_\n-            long, // int_\n-            ulong, // uint_\n-            double, // double_\n-            string, // string_\n-            immutable(ubyte)[], // bytes_\n-            List, // list (abstract \u2014 ArrayList for literals, subclass for lazy)\n-            Value[string], // map (string-keyed)\n-            Entry, // entry (lazy)\n-            Duration, // duration\n-            SysTime, // timestamp\n-            Err, // err\n-            );\n-\n-    /// The underlying SumType storage.\n-    Inner inner;\n-    alias inner this;\n-\n-    /// Error sentinel \u2014 carries a message describing what went wrong.\n-    static struct Err\n-    {\n-        /// The error message.\n-        string message;\n-    }\n-\n-    /// Construct a Value from any supported type.\n-    this(T)(T val)\n-    {\n-        inner = Inner(val);\n-    }\n-\n-    /// Convenience: null value.\n-    static Value null_()\n-    {\n-        Value v;\n-        v.inner = Inner(null);\n-        return v;\n-    }\n-\n-    /// Convenience: error value.\n-    static Value err(string msg)\n-    {\n-        Value v;\n-        v.inner = Inner(Err(msg));\n-        return v;\n-    }\n-\n-    /// Returns the type tag for this value.\n-    Type type()\n-    {\n-        return inner.match!((ref typeof(null) _) => Type.null_,\n-                (ref bool _) => Type.bool_, (ref long _) => Type.int_,\n-                (ref ulong _) => Type.uint_, (ref double _) => Type.double_,\n-                (ref string _) => Type.string_, (ref immutable(ubyte)[] _) => Type.bytes_,\n-                (ref List _) => Type.list, (ref Value[string] _) => Type.map,\n-                (ref Entry _) => Type.entry, (ref Duration _) => Type.duration,\n-                (ref SysTime _) => Type.timestamp, (ref Err _) => Type.err,);\n-    }\n-\n-    /// Deep equality comparison for Values.\n-    bool opEquals()(auto ref const Value other) const\n-    {\n-        return valueEquals(this, other);\n-    }\n-\n-    /// Extract the underlying D value of type T.\n-    /// Throws `EvalException` if the Value holds an error or a different type.\n-    T get(T)() const\n-    {\n-        auto self = cast(Value) this;\n-        if (self.type == Type.err)\n-        {\n-            auto e = self.inner.match!((ref Err err) => err.message, (ref _) => \"unknown error\");\n-            throw new EvalException(\"Value is an error: \" ~ e);\n-        }\n-        auto result = self.inner.match!((ref T val) => Nullable!T(val), (ref _) => Nullable!T.init);\n-        if (result.isNull)\n-        {\n-            import std.conv : to;\n-\n-            throw new EvalException(\"type mismatch: expected \" ~ T.stringof);\n-        }\n-        return result.get;\n-    }\n-\n-    /// Get the error message from an error Value, or null if not an error.\n-    string errMessage() const\n-    {\n-        auto self = cast(Value) this;\n-        return self.inner.match!((ref Err e) => e.message, (ref _) => null);\n-    }\n-\n-    /// Human-readable string representation of this Value.\n-    string toString() const\n-    {\n-        auto self = cast(Value) this;\n-        return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => fmtInt(i),\n-            (ref ulong u) => fmtUint(u),\n-            (ref double d) => fmtDouble(d),\n-            (ref string s) => fmtString(s),\n-            (ref immutable(ubyte)[] b) => fmtBytes(b),\n-            (ref List l) => fmtList(l),\n-            (ref Value[string] m) => fmtMap(m),\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) => fmtDuration(d),\n-            (ref SysTime t) => fmtTimestamp(t),\n-            (ref Err e) => \"error: \" ~ e.message,\n-        );\n-    }\n-\n-    /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n-    /// the match table above as a clean, scannable list.\n-    private static:\n-\n-    string fmtInt(long i)\n-    {\n-        import std.conv : to;\n-        return i.to!string;\n-    }\n-\n-    string fmtUint(ulong u)\n-    {\n-        import std.conv : to;\n-        return u.to!string ~ \"u\";\n-    }\n-\n-    string fmtDouble(double d)\n-    {\n-        import std.conv : to;\n-        return d.to!string;\n-    }\n-\n-    string fmtString(string s)\n-    {\n-        char[] buf;\n-        buf ~= '\"';\n-        foreach (c; s)\n-        {\n-            switch (c)\n-            {\n-                case '\"':  buf ~= `\\\"`; break;\n-                case '\\\\': buf ~= `\\\\`; break;\n-                case '\\n': buf ~= `\\n`; break;\n-                case '\\r': buf ~= `\\r`; break;\n-                case '\\t': buf ~= `\\t`; break;\n-                default:   buf ~= c;    break;\n-            }\n-        }\n-        buf ~= '\"';\n-        return cast(string) buf;\n-    }\n-\n-    string fmtBytes(immutable(ubyte)[] bytes)\n-    {\n-        import std.format : format;\n-        char[] buf;\n-        buf ~= \"b\\\"\";\n-        foreach (b; bytes)\n-            buf ~= format!\"%02x\"(b);\n-        buf ~= '\"';\n-        return cast(string) buf;\n-    }\n-\n-    string fmtList(List list)\n-    {\n-        char[] buf;\n-        buf ~= '[';\n-        foreach (i; 0 .. list.length)\n-        {\n-            if (i > 0) buf ~= \", \";\n-            buf ~= list.index(i).toString();\n-        }\n-        buf ~= ']';\n-        return cast(string) buf;\n-    }\n-\n-    string fmtMap(Value[string] map)\n-    {\n-        import std.algorithm : sort;\n-        char[] buf;\n-        buf ~= '{';\n-        auto keys = map.keys;\n-        keys.sort();\n-        bool first = true;\n-        foreach (k; keys)\n-        {\n-            if (!first) buf ~= \", \";\n-            first = false;\n-            buf ~= fmtString(k);\n-            buf ~= \": \";\n-            buf ~= map[k].toString();\n-        }\n-        buf ~= '}';\n-        return cast(string) buf;\n-    }\n-\n-    string fmtDuration(Duration d)\n-    {\n-        import std.format : format;\n-        long totalSecs = d.total!\"seconds\";\n-        bool negative = totalSecs < 0;\n-        if (negative) totalSecs = -totalSecs;\n-        long rem = totalSecs;\n-        long h = rem / 3600;\n-        rem %= 3600;\n-        long m = rem / 60;\n-        long sec = rem % 60;\n-        char[] buf;\n-        if (negative) buf ~= '-';\n-        buf ~= \"PT\";\n-        if (h > 0) buf ~= format!\"%dH\"(h);\n-        if (m > 0) buf ~= format!\"%dM\"(m);\n-        if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n-        return cast(string) buf;\n-    }\n-\n-    string fmtTimestamp(SysTime st)\n-    {\n-        import std.format : format;\n-        auto utc = st.toUTC();\n-        return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n-            utc.year, cast(int) utc.month, utc.day,\n-            utc.hour, utc.minute, utc.second);\n-    }\n-\n-    /// Hash support (needed when opEquals is defined).\n-    size_t toHash() const nothrow @trusted\n-    {\n-        try\n-        {\n-            auto self = cast(Value) this;\n-            return hashOf(cast(int) self.type());\n-        }\n-        catch (Exception)\n-        {\n-            return 0;\n-        }\n-    }\n-}\n-\n-/// Extract a value of type T from a Value's inner SumType.\n-/// Asserts that the Value actually holds type T \u2014 only call this\n-/// when the type has already been verified via `Value.type()`.\n-private T unsafeGet(T)(Value v)\n-{\n-    return v.inner.match!((ref T val) => val, (ref _) {\n-        assert(0, \"unsafeGet!\" ~ T.stringof ~ \": type tag lied\");\n-        static if (is(T == class) || is(T == interface))\n-            return null;\n-        else\n-            return T.init;\n-    });\n-}\n-\n-/// Deep equality comparison of two Values.\n-private bool valueEquals(const Value a, const Value b)\n-{\n-    auto ma = cast(Value) a;\n-    auto mb = cast(Value) b;\n-\n-    auto ta = ma.type();\n-    auto tb = mb.type();\n-\n-    if (ta == Value.Type.err || tb == Value.Type.err)\n-        return false;\n-\n-    if (ta == Value.Type.null_ && tb == Value.Type.null_)\n-        return true;\n-\n-    if (ta == Value.Type.bool_ && tb == Value.Type.bool_)\n-        return unsafeGet!bool(ma) == unsafeGet!bool(mb);\n-\n-    if (ta == Value.Type.int_ && tb == Value.Type.int_)\n-        return unsafeGet!long(ma) == unsafeGet!long(mb);\n-\n-    if (ta == Value.Type.uint_ && tb == Value.Type.uint_)\n-        return unsafeGet!ulong(ma) == unsafeGet!ulong(mb);\n-\n-    if (ta == Value.Type.double_ && tb == Value.Type.double_)\n-        return unsafeGet!double(ma) == unsafeGet!double(mb);\n-\n-    if (ta == Value.Type.string_ && tb == Value.Type.string_)\n-        return unsafeGet!string(ma) == unsafeGet!string(mb);\n-\n-    if (ta == Value.Type.bytes_ && tb == Value.Type.bytes_)\n-        return unsafeGet!(immutable(ubyte)[])(ma) == unsafeGet!(immutable(ubyte)[])(mb);\n-\n-    if (ta == Value.Type.list && tb == Value.Type.list)\n-    {\n-        auto la = unsafeGet!List(ma);\n-        auto lb = unsafeGet!List(mb);\n-        if (la.length != lb.length)\n-            return false;\n-        foreach (i; 0 .. la.length)\n-            if (!valueEquals(la.index(i), lb.index(i)))\n-                return false;\n-        return true;\n-    }\n-\n-    if (ta == Value.Type.map && tb == Value.Type.map)\n-    {\n-        auto mapA = unsafeGet!(Value[string])(ma);\n-        auto mapB = unsafeGet!(Value[string])(mb);\n-        if (mapA.length != mapB.length)\n-            return false;\n-        foreach (k, v; mapA)\n-        {\n-            auto pb = k in mapB;\n-            if (pb is null || !valueEquals(v, *pb))\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    if (ta == Value.Type.duration && tb == Value.Type.duration)\n-        return unsafeGet!Duration(ma) == unsafeGet!Duration(mb);\n-\n-    if (ta == Value.Type.timestamp && tb == Value.Type.timestamp)\n-        return unsafeGet!SysTime(ma).toUnixTime() == unsafeGet!SysTime(mb).toUnixTime();\n-\n-    return false;\n-}\n-\n-/// Convenience helper: construct a Value from a D value.\n-Value value(T)(T val)\n-{\n-    return Value(val);\n-}\n-\n-/// Convenience: construct a list Value from a Value array.\n-Value value(T : Value[])(T elems)\n-{\n-    return Value(cast(List) new ArrayList(elems));\n-}\n-\n-@(\"Value: construct and check types\")\n-unittest\n-{\n-    import dshould;\n-\n-    value(true).type.should.be(Value.Type.bool_);\n-    value(42L).type.should.be(Value.Type.int_);\n-    value(42UL).type.should.be(Value.Type.uint_);\n-    value(3.14).type.should.be(Value.Type.double_);\n-    value(\"hello\").type.should.be(Value.Type.string_);\n-    Value.null_().type.should.be(Value.Type.null_);\n-    Value.err(\"oops\").type.should.be(Value.Type.err);\n-\n-    import core.time : seconds;\n-\n-    value(30.seconds).type.should.be(Value.Type.duration);\n-\n-    import std.datetime.systime : SysTime, Clock;\n-\n-    value(Clock.currTime()).type.should.be(Value.Type.timestamp);\n-\n-    // List via ArrayList\n-    value([value(1L), value(2L)]).type.should.be(Value.Type.list);\n-}\n-\n-@(\"Value: toString basics\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Null\n-    Value.null_().toString().should.be(\"null\");\n-\n-    // Booleans\n-    value(true).toString().should.be(\"true\");\n-    value(false).toString().should.be(\"false\");\n-\n-    // Integers\n-    value(0L).toString().should.be(\"0\");\n-    value(42L).toString().should.be(\"42\");\n-    value(-7L).toString().should.be(\"-7\");\n-\n-    // Unsigned integers\n-    value(42UL).toString().should.be(\"42u\");\n-    value(0UL).toString().should.be(\"0u\");\n-\n-    // Doubles\n-    value(3.14).toString().should.be(\"3.14\");\n-    value(0.0).toString().should.be(\"0\");\n-    value(-2.5).toString().should.be(\"-2.5\");\n-\n-    // Strings\n-    value(\"hello\").toString().should.be(`\"hello\"`);\n-    value(\"\").toString().should.be(`\"\"`);\n-    value(\"with \\\"quotes\\\"\").toString().should.be(`\"with \\\"quotes\\\"\"`);\n-    value(\"line\\nbreak\").toString().should.be(`\"line\\nbreak\"`);\n-    value(\"tab\\there\").toString().should.be(`\"tab\\there\"`);\n-\n-    // Bytes\n-    value(cast(immutable(ubyte)[])[0x48, 0x69]).toString().should.be(`b\"4869\"`);\n-    value(cast(immutable(ubyte)[])[]).toString().should.be(`b\"\"`);\n-\n-    // Errors\n-    Value.err(\"something broke\").toString().should.be(\"error: something broke\");\n-}\n-\n-@(\"Value: toString collections\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Lists\n-    value(cast(Value[])[]).toString().should.be(\"[]\");\n-    value([value(1L), value(2L), value(3L)]).toString().should.be(\"[1, 2, 3]\");\n-    value([value(\"a\"), value(\"b\")]).toString().should.be(`[\"a\", \"b\"]`);\n-\n-    // Nested lists\n-    value([value([value(1L), value(2L)]), value([value(3L)])]).toString()\n-        .should.be(\"[[1, 2], [3]]\");\n-\n-    // Maps (keys sorted alphabetically)\n-    Value[string] m;\n-    m[\"b\"] = value(2L);\n-    m[\"a\"] = value(1L);\n-    Value(m).toString().should.be(`{\"a\": 1, \"b\": 2}`);\n-\n-    // Empty map\n-    Value[string] empty;\n-    Value(empty).toString().should.be(\"{}\");\n-}\n-\n-@(\"Value: toString duration and timestamp\")\n-unittest\n-{\n-    import dshould;\n-    import core.time : hours, minutes, seconds;\n-    import std.datetime.systime : SysTime;\n-    import std.datetime.date : DateTime;\n-    import std.datetime.timezone : UTC;\n-\n-    // Durations\n-    value(1.hours + 30.minutes).toString().should.be(\"PT1H30M\");\n-    value(90.seconds).toString().should.be(\"PT1M30S\");\n-    value(0.seconds).toString().should.be(\"PT0S\");\n-    value(2.hours).toString().should.be(\"PT2H\");\n-\n-    // Timestamps\n-    value(SysTime(DateTime(2023, 1, 15, 12, 30, 45), UTC())).toString()\n-        .should.be(\"2023-01-15T12:30:45Z\");\n-}\n-\n-@(\"Value: deep equality\")\n-unittest\n-{\n-    import dshould;\n-\n-    (value(42L) == value(42L)).should.be(true);\n-    (value(42L) == value(43L)).should.be(false);\n-    (value(true) == value(true)).should.be(true);\n-    (value(true) == value(false)).should.be(false);\n-    (value(\"abc\") == value(\"abc\")).should.be(true);\n-    (value(\"abc\") == value(\"def\")).should.be(false);\n-    (Value.null_() == Value.null_()).should.be(true);\n-\n-    (value([value(1L), value(2L)]) == value([value(1L), value(2L)])).should.be(true);\n-    (value([value(1L), value(2L)]) == value([value(1L), value(3L)])).should.be(false);\n-\n-    (Value.err(\"a\") == Value.err(\"a\")).should.be(false);\n-}\ndfmt reformatted: source/decel/package.d\n--- a/source/decel/package.d\t2026-02-17 14:39:29.963264373 +0100\n+++ b/source/decel/package.d\t2026-02-17 14:39:29.975641253 +0100\n@@ -1,41 +0,0 @@\n-/++\n- + decel - A Google Common Expression Language (CEL) implementation for D.\n- +\n- + CEL is a non-Turing-complete expression language designed for fast, portable,\n- + and safe evaluation of simple expressions.\n- +\n- + The public API consists of:\n- + $(UL\n- +   $(LI `evaluate` / `evaluateWithMacros` \u2014 evaluate a CEL expression string)\n- +   $(LI `now()` \u2014 built-in function returning the current timestamp)\n- +   $(LI `Value` / `value` \u2014 the runtime value type and convenience constructor)\n- +   $(LI `Context` / `contextFrom` / `emptyContext` / `bindContext` \u2014 variable bindings)\n- +   $(LI `Macro` / `MethodMacro` / `Env` \u2014 extension points for custom functions)\n- +   $(LI `EvalException` \u2014 thrown on syntax errors)\n- + )\n- +\n- + See_Also: https://cel.dev/\n- +/\n-module decel;\n-\n-// Value types\n-public import decel.value : Value, Entry, List, ArrayList, value;\n-public import std.typecons : Nullable, nullable;\n-\n-// Context (variable bindings)\n-public import decel.context : Context, contextFrom, emptyContext, bindContext;\n-\n-// Evaluation\n-public import decel.eval : evaluate, evaluateWithMacros;\n-\n-// Exception type (re-exported via eval and env too, but canonical source is here)\n-public import decel.exception : EvalException;\n-\n-// Extension points\n-public import decel.env : Env, Macro, MethodMacro, TokenRange;\n-\n-// Lexer (needed for custom macros)\n-public import decel.lexer : Token;\n-\n-// Parser (needed for custom macros that parse arguments)\n-public import decel.eval : parseExpr, parseArgList;\ndfmt reformatted: source/decel/lexer.d\n--- a/source/decel/lexer.d\t2026-02-17 14:39:29.963094773 +0100\n+++ b/source/decel/lexer.d\t2026-02-17 14:39:29.981658832 +0100\n@@ -1,541 +0,0 @@\n-/++\n- + CEL Lexer \u2014 tokenizes CEL expression source into a token stream.\n- +/\n-module decel.lexer;\n-\n-/// A single token produced by the lexer.\n-struct Token\n-{\n-    /// The kind of token.\n-    Kind kind;\n-    /// The source text of this token.\n-    string text;\n-    /// Byte offset in the source where this token starts.\n-    size_t pos;\n-\n-    /// All possible token kinds.\n-    enum Kind\n-    {\n-        // Literals\n-        intLit,\n-        uintLit,\n-        floatLit,\n-        stringLit,\n-        bytesLit,\n-\n-        // Identifiers and keywords\n-        ident,\n-        trueKw,\n-        falseKw,\n-        nullKw,\n-        inKw,\n-\n-        // Operators\n-        plus,\n-        minus,\n-        star,\n-        slash,\n-        percent,\n-        bang,\n-        eq,\n-        eqEq,\n-        bangEq,\n-        lt,\n-        ltEq,\n-        gt,\n-        gtEq,\n-        ampAmp,\n-        pipePipe,\n-        question,\n-        colon,\n-\n-        // Punctuation\n-        lparen,\n-        rparen,\n-        lbracket,\n-        rbracket,\n-        lbrace,\n-        rbrace,\n-        dot,\n-        comma,\n-\n-        // Special\n-        eof,\n-        err,\n-    }\n-\n-    /// Human-readable description for error messages.\n-    string toString() const\n-    {\n-        import std.format : format;\n-\n-        if (kind == Kind.eof)\n-            return \"<eof>\";\n-        if (kind == Kind.err)\n-            return format!\"<error: %s>\"(text);\n-        return text;\n-    }\n-}\n-\n-/// Tokenize a CEL expression string into a token array.\n-Token[] tokenize(string source)\n-{\n-    Token[] tokens;\n-    size_t i = 0;\n-\n-    while (i < source.length)\n-    {\n-        if (source[i] == ' ' || source[i] == '\\t' || source[i] == '\\n' || source[i] == '\\r')\n-        {\n-            i++;\n-            continue;\n-        }\n-\n-        if (i + 1 < source.length && source[i] == '/' && source[i + 1] == '/')\n-        {\n-            while (i < source.length && source[i] != '\\n')\n-                i++;\n-            continue;\n-        }\n-\n-        auto start = i;\n-\n-        if (isIdentStart(source[i]))\n-        {\n-            while (i < source.length && isIdentCont(source[i]))\n-                i++;\n-            auto word = source[start .. i];\n-\n-            if ((word == \"b\" || word == \"B\" || word == \"r\" || word == \"R\"\n-                    || word == \"br\" || word == \"bR\" || word == \"Br\" || word == \"BR\"\n-                    || word == \"rb\" || word == \"rB\" || word == \"Rb\" || word == \"RB\")\n-                    && i < source.length && (source[i] == '\"' || source[i] == '\\''))\n-            {\n-                bool isBytes = false;\n-                bool isRaw = false;\n-                foreach (c; word)\n-                {\n-                    if (c == 'b' || c == 'B')\n-                        isBytes = true;\n-                    if (c == 'r' || c == 'R')\n-                        isRaw = true;\n-                }\n-                auto tok = lexString(source, i, start, isRaw);\n-                tok.kind = isBytes ? Token.Kind.bytesLit : Token.Kind.stringLit;\n-                tokens ~= tok;\n-                i = start + tok.text.length;\n-                continue;\n-            }\n-\n-            auto kind = identKind(word);\n-            tokens ~= Token(kind, word, start);\n-            continue;\n-        }\n-\n-        if (isDigit(source[i]) || (source[i] == '.' && i + 1 < source.length\n-                && isDigit(source[i + 1])))\n-        {\n-            tokens ~= lexNumber(source, i, start);\n-            continue;\n-        }\n-\n-        if (source[i] == '\"' || source[i] == '\\'')\n-        {\n-            auto tok = lexString(source, i, start, false);\n-            tokens ~= tok;\n-            i = start + tok.text.length;\n-            continue;\n-        }\n-\n-        if (i + 1 < source.length)\n-        {\n-            auto two = source[i .. i + 2];\n-            Token.Kind twoKind;\n-            bool foundTwo = true;\n-            switch (two)\n-            {\n-            case \"==\":\n-                twoKind = Token.Kind.eqEq;\n-                break;\n-            case \"!=\":\n-                twoKind = Token.Kind.bangEq;\n-                break;\n-            case \"<=\":\n-                twoKind = Token.Kind.ltEq;\n-                break;\n-            case \">=\":\n-                twoKind = Token.Kind.gtEq;\n-                break;\n-            case \"&&\":\n-                twoKind = Token.Kind.ampAmp;\n-                break;\n-            case \"||\":\n-                twoKind = Token.Kind.pipePipe;\n-                break;\n-            default:\n-                foundTwo = false;\n-                break;\n-            }\n-            if (foundTwo)\n-            {\n-                tokens ~= Token(twoKind, two, start);\n-                i += 2;\n-                continue;\n-            }\n-        }\n-\n-        Token.Kind singleKind;\n-        bool foundSingle = true;\n-        switch (source[i])\n-        {\n-        case '+':\n-            singleKind = Token.Kind.plus;\n-            break;\n-        case '-':\n-            singleKind = Token.Kind.minus;\n-            break;\n-        case '*':\n-            singleKind = Token.Kind.star;\n-            break;\n-        case '/':\n-            singleKind = Token.Kind.slash;\n-            break;\n-        case '%':\n-            singleKind = Token.Kind.percent;\n-            break;\n-        case '!':\n-            singleKind = Token.Kind.bang;\n-            break;\n-        case '<':\n-            singleKind = Token.Kind.lt;\n-            break;\n-        case '>':\n-            singleKind = Token.Kind.gt;\n-            break;\n-        case '?':\n-            singleKind = Token.Kind.question;\n-            break;\n-        case ':':\n-            singleKind = Token.Kind.colon;\n-            break;\n-        case '(':\n-            singleKind = Token.Kind.lparen;\n-            break;\n-        case ')':\n-            singleKind = Token.Kind.rparen;\n-            break;\n-        case '[':\n-            singleKind = Token.Kind.lbracket;\n-            break;\n-        case ']':\n-            singleKind = Token.Kind.rbracket;\n-            break;\n-        case '{':\n-            singleKind = Token.Kind.lbrace;\n-            break;\n-        case '}':\n-            singleKind = Token.Kind.rbrace;\n-            break;\n-        case '.':\n-            singleKind = Token.Kind.dot;\n-            break;\n-        case ',':\n-            singleKind = Token.Kind.comma;\n-            break;\n-        case '=':\n-            singleKind = Token.Kind.eq;\n-            break;\n-        default:\n-            foundSingle = false;\n-            break;\n-        }\n-        if (foundSingle)\n-        {\n-            tokens ~= Token(singleKind, source[i .. i + 1], start);\n-            i++;\n-            continue;\n-        }\n-\n-        tokens ~= Token(Token.Kind.err, source[i .. i + 1], start);\n-        i++;\n-    }\n-\n-    tokens ~= Token(Token.Kind.eof, \"\", source.length);\n-    return tokens;\n-}\n-\n-private bool isIdentStart(char c)\n-{\n-    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';\n-}\n-\n-private bool isIdentCont(char c)\n-{\n-    return isIdentStart(c) || isDigit(c);\n-}\n-\n-private bool isDigit(char c)\n-{\n-    return c >= '0' && c <= '9';\n-}\n-\n-private bool isHexDigit(char c)\n-{\n-    return isDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n-}\n-\n-private Token.Kind identKind(string word)\n-{\n-    switch (word)\n-    {\n-    case \"true\":\n-        return Token.Kind.trueKw;\n-    case \"false\":\n-        return Token.Kind.falseKw;\n-    case \"null\":\n-        return Token.Kind.nullKw;\n-    case \"in\":\n-        return Token.Kind.inKw;\n-    default:\n-        return Token.Kind.ident;\n-    }\n-}\n-\n-private Token lexNumber(string source, ref size_t i, size_t start)\n-{\n-    bool isFloat = false;\n-\n-    if (i + 1 < source.length && source[i] == '0' && (source[i + 1] == 'x' || source[i + 1] == 'X'))\n-    {\n-        i += 2;\n-        if (i >= source.length || !isHexDigit(source[i]))\n-            return Token(Token.Kind.err, source[start .. i], start);\n-        while (i < source.length && isHexDigit(source[i]))\n-            i++;\n-        if (i < source.length && (source[i] == 'u' || source[i] == 'U'))\n-        {\n-            i++;\n-            return Token(Token.Kind.uintLit, source[start .. i], start);\n-        }\n-        return Token(Token.Kind.intLit, source[start .. i], start);\n-    }\n-\n-    while (i < source.length && isDigit(source[i]))\n-        i++;\n-\n-    if (i < source.length && source[i] == '.' && (i + 1 >= source.length || source[i + 1] != '.'))\n-    {\n-        isFloat = true;\n-        i++;\n-        while (i < source.length && isDigit(source[i]))\n-            i++;\n-    }\n-\n-    if (i < source.length && (source[i] == 'e' || source[i] == 'E'))\n-    {\n-        isFloat = true;\n-        i++;\n-        if (i < source.length && (source[i] == '+' || source[i] == '-'))\n-            i++;\n-        if (i >= source.length || !isDigit(source[i]))\n-            return Token(Token.Kind.err, source[start .. i], start);\n-        while (i < source.length && isDigit(source[i]))\n-            i++;\n-    }\n-\n-    if (isFloat)\n-        return Token(Token.Kind.floatLit, source[start .. i], start);\n-\n-    if (i < source.length && (source[i] == 'u' || source[i] == 'U'))\n-    {\n-        i++;\n-        return Token(Token.Kind.uintLit, source[start .. i], start);\n-    }\n-\n-    return Token(Token.Kind.intLit, source[start .. i], start);\n-}\n-\n-private Token lexString(string source, ref size_t i, size_t start, bool isRaw)\n-{\n-    const quote = source[i];\n-    bool triple = false;\n-\n-    if (i + 2 < source.length && source[i + 1] == quote && source[i + 2] == quote)\n-    {\n-        triple = true;\n-        i += 3;\n-    }\n-    else\n-    {\n-        i++;\n-    }\n-\n-    while (i < source.length)\n-    {\n-        if (source[i] == '\\\\' && !isRaw)\n-        {\n-            i += 2;\n-            continue;\n-        }\n-        if (source[i] == quote)\n-        {\n-            if (triple)\n-            {\n-                if (i + 2 < source.length && source[i + 1] == quote && source[i + 2] == quote)\n-                {\n-                    i += 3;\n-                    return Token(Token.Kind.stringLit, source[start .. i], start);\n-                }\n-                i++;\n-                continue;\n-            }\n-            else\n-            {\n-                i++;\n-                return Token(Token.Kind.stringLit, source[start .. i], start);\n-            }\n-        }\n-        if (!triple && (source[i] == '\\n' || source[i] == '\\r'))\n-        {\n-            return Token(Token.Kind.err, source[start .. i], start);\n-        }\n-        i++;\n-    }\n-\n-    return Token(Token.Kind.err, source[start .. i], start);\n-}\n-\n-@(\"Lexer: simple arithmetic\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"1 + 2 * 3\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([intLit, plus, intLit, star, intLit, eof]);\n-    tokens.map!\"a.text\".should.be([\"1\", \"+\", \"2\", \"*\", \"3\", \"\"]);\n-}\n-\n-@(\"Lexer: identifiers and keywords\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"x in true false null foo_bar\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([\n-        ident, inKw, trueKw, falseKw, nullKw, ident, eof\n-    ]);\n-    tokens.map!\"a.text\".should.be([\n-        \"x\", \"in\", \"true\", \"false\", \"null\", \"foo_bar\", \"\"\n-    ]);\n-}\n-\n-@(\"Lexer: comparison and logical operators\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"a == b && c != d || e <= f >= g\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([\n-        ident, eqEq, ident, ampAmp, ident, bangEq, ident, pipePipe, ident,\n-        ltEq, ident, gtEq, ident, eof\n-    ]);\n-}\n-\n-@(\"Lexer: string literals\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(`\"hello\" 'world'`);\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([stringLit, stringLit, eof]);\n-    tokens.map!\"a.text\".should.be([`\"hello\"`, `'world'`, \"\"]);\n-}\n-\n-@(\"Lexer: numeric literals\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"42 3u 0xFF 0x1Au 3.14 1e10 2.5e-3\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([\n-        intLit, uintLit, intLit, uintLit, floatLit, floatLit, floatLit, eof\n-    ]);\n-    tokens.map!\"a.text\".should.be([\n-        \"42\", \"3u\", \"0xFF\", \"0x1Au\", \"3.14\", \"1e10\", \"2.5e-3\", \"\"\n-    ]);\n-}\n-\n-@(\"Lexer: punctuation and grouping\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"foo(a, b[0]).bar ? x : y\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([\n-        ident, lparen, ident, comma, ident, lbracket, intLit, rbracket, rparen,\n-        dot, ident, question, ident, colon, ident, eof\n-    ]);\n-}\n-\n-@(\"Lexer: escape sequences in strings\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(`\"hello\\nworld\" \"tab\\there\"`);\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([stringLit, stringLit, eof]);\n-}\n-\n-@(\"Lexer: empty input\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([eof]);\n-}\n-\n-@(\"Lexer: single = token\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(`a = \"b\"`);\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([ident, eq, stringLit, eof]);\n-\n-    // == is still a separate token\n-    auto tokens2 = tokenize(`a == \"b\"`);\n-    with (Token.Kind)\n-        tokens2.map!\"a.kind\".should.be([ident, eqEq, stringLit, eof]);\n-}\n-\n-@(\"Lexer: unary negation and subtraction\")\n-unittest\n-{\n-    import std.algorithm : map;\n-    import dshould;\n-\n-    auto tokens = tokenize(\"-1 + a - b\");\n-    with (Token.Kind)\n-        tokens.map!\"a.kind\".should.be([\n-        minus, intLit, plus, ident, minus, ident, eof\n-    ]);\n-}\ndfmt reformatted: source/decel/exception.d\n--- a/source/decel/exception.d\t2026-02-17 14:39:29.962654712 +0100\n+++ b/source/decel/exception.d\t2026-02-17 14:39:29.987242968 +0100\n@@ -1,33 +0,0 @@\n-/++\n- + CEL Exception type \u2014 shared across the decel library.\n- +/\n-module decel.exception;\n-\n-/++\n- + Exception thrown for parse errors (syntax errors, unexpected tokens)\n- + and type-mismatch errors when extracting values via `Value.get!T`.\n- +\n- + Evaluation errors (division by zero, missing keys) are represented\n- + as `Value.err` instead \u2014 only structural/API misuse throws.\n- +/\n-class EvalException : Exception\n-{\n-    /// Byte offset in the source where the error occurred (0 for non-parse errors).\n-    immutable size_t position;\n-\n-    /// Construct an EvalException with a message and source position.\n-    this(string msg, size_t pos, string file = __FILE__, size_t line = __LINE__)\n-    {\n-        import std.format : format;\n-\n-        super(format!\"at position %d: %s\"(pos, msg), file, line);\n-        position = pos;\n-    }\n-\n-    /// Construct an EvalException with just a message (no source position).\n-    this(string msg, string file = __FILE__, size_t line = __LINE__)\n-    {\n-        super(msg, file, line);\n-        position = 0;\n-    }\n-}\ndfmt reformatted: source/decel/eval.d\n--- a/source/decel/eval.d\t2026-02-17 14:39:29.962476924 +0100\n+++ b/source/decel/eval.d\t2026-02-17 14:39:29.992685676 +0100\n@@ -1,2944 +0,0 @@\n-/++\n- + CEL Evaluator \u2014 single-pass recursive descent interpreter.\n- +\n- + Tokenizes and evaluates a CEL expression in one pass, producing a Value.\n- + Uses Pratt parsing for correct operator precedence.\n- +\n- + Three concerns are cleanly separated:\n- + $(UL\n- +   $(LI `TokenRange` \u2014 linear parser state (token cursor))\n- +   $(LI `Env` \u2014 global configuration (macros, method macros))\n- +   $(LI `Context` \u2014 lexical scope (variable bindings))\n- + )\n- +\n- + Every parse/eval function takes all three explicitly, making data flow\n- + clear and avoiding mutation of shared state.\n- +/\n-module decel.eval;\n-\n-import decel.context;\n-import decel.env;\n-import decel.lexer;\n-import decel.value;\n-\n-import core.time : Duration, hours, minutes, seconds, hnsecs, dur;\n-import std.conv : to, ConvException;\n-import std.datetime.systime : SysTime;\n-import std.datetime.timezone : UTC;\n-import std.sumtype : match;\n-import std.typecons : Nullable, nullable;\n-\n-// Re-export EvalException and kindName so existing callers still work.\n-public import decel.exception : EvalException;\n-public import decel.env : kindName;\n-\n-/// Evaluate a CEL expression string against a context.\n-Value evaluate(string source, Context ctx)\n-{\n-    auto env = standardEnv();\n-    auto tokens = tokenize(source);\n-    auto r = TokenRange(tokens, 0);\n-    auto result = parseExpr(r, env, ctx, 0);\n-    r.expect(Token.Kind.eof);\n-    return result;\n-}\n-\n-/// Evaluate a CEL expression with custom macros.\n-Value evaluateWithMacros(string source, Context ctx, Macro[string] macros)\n-{\n-    auto env = standardEnv();\n-    if (macros !is null)\n-    {\n-        foreach (k, v; macros)\n-            env.macros[k] = v;\n-    }\n-    auto tokens = tokenize(source);\n-    auto r = TokenRange(tokens, 0);\n-    auto result = parseExpr(r, env, ctx, 0);\n-    r.expect(Token.Kind.eof);\n-    return result;\n-}\n-\n-/// Build the standard environment with all built-in macros.\n-private Env standardEnv()\n-{\n-    Env e;\n-    e.macros = builtinMacros();\n-    e.methodMacros = builtinMethodMacros();\n-    return e;\n-}\n-\n-// \u2500\u2500 Expression parsing (Pratt) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-/// Parse an expression with the given minimum precedence.\n-Value parseExpr(ref TokenRange r, const Env env, Context ctx, int minPrec)\n-{\n-    auto lhs = parseUnary(r, env, ctx);\n-\n-    while (true)\n-    {\n-        // Entry continuation: let the entry parse arbitrary syntax\n-        // (e.g. {attr == \"val\"}) before we check infix operators.\n-        auto entryC = tryGet!Entry(lhs);\n-        if (!entryC.isNull)\n-        {\n-            auto cont = entryC.get.evalContinuation(lhs, r, env, ctx);\n-            if (!cont.isNull)\n-            {\n-                lhs = cont.get;\n-                continue; // re-enter loop \u2014 the new lhs might also be an Entry\n-            }\n-        }\n-\n-        auto tok = r.peek();\n-        auto prec = infixPrec(tok.kind);\n-        if (prec < 0 || prec < minPrec)\n-            break;\n-\n-        // Ternary conditional: expr ? expr : expr\n-        if (tok.kind == Token.Kind.question)\n-        {\n-            r.advance();\n-            lhs = parseTernary(r, env, ctx, lhs);\n-            continue;\n-        }\n-\n-        // `in` operator\n-        if (tok.kind == Token.Kind.inKw)\n-        {\n-            r.advance();\n-            auto rhs = parseExpr(r, env, ctx, prec + 1);\n-            lhs = evalIn(lhs, rhs);\n-            continue;\n-        }\n-\n-        // Member access: expr.ident\n-        if (tok.kind == Token.Kind.dot)\n-        {\n-            r.advance();\n-            auto ident = r.expect(Token.Kind.ident);\n-\n-            // Method call: expr.ident(args...)\n-            if (r.peek().kind == Token.Kind.lparen)\n-            {\n-                r.advance();\n-                // Check global method macros first\n-                if (auto mm = ident.text in env.methodMacros)\n-                {\n-                    lhs = (*mm)(lhs, r, env, ctx);\n-                    continue;\n-                }\n-                // Check Entry-level method macros\n-                auto entryMM = tryGet!Entry(lhs);\n-                if (!entryMM.isNull)\n-                {\n-                    auto emResult = entryMM.get.evalMacro(ident.text, lhs, r, env, ctx);\n-                    if (!emResult.isNull)\n-                    {\n-                        lhs = emResult.get;\n-                        continue;\n-                    }\n-                }\n-                auto args = parseArgList(r, env, ctx);\n-                r.expect(Token.Kind.rparen);\n-                lhs = evalMethod(lhs, ident.text, args);\n-            }\n-            else\n-            {\n-                lhs = evalMember(lhs, ident.text);\n-            }\n-            continue;\n-        }\n-\n-        // Index: expr[expr]\n-        if (tok.kind == Token.Kind.lbracket)\n-        {\n-            r.advance();\n-            auto index = parseExpr(r, env, ctx, 0);\n-            r.expect(Token.Kind.rbracket);\n-            lhs = evalIndex(lhs, index);\n-            continue;\n-        }\n-\n-        // Binary operator\n-        r.advance();\n-\n-        // Short-circuit: && and ||\n-        if (tok.kind == Token.Kind.ampAmp)\n-        {\n-            auto rhs = parseExpr(r, env, ctx, prec + 1);\n-            if (isFalsy(lhs))\n-                continue; // lhs stays false, absorbs RHS errors\n-            if (isTruthy(lhs))\n-            {\n-                lhs = toBool(rhs);\n-                continue;\n-            }\n-            // lhs is non-bool error \u2014 propagate\n-            lhs = Value.err(\"'&&' operand is not a bool: \" ~ typeName(lhs));\n-            continue;\n-        }\n-        if (tok.kind == Token.Kind.pipePipe)\n-        {\n-            auto rhs = parseExpr(r, env, ctx, prec + 1);\n-            if (isTruthy(lhs))\n-                continue; // lhs stays true, absorbs RHS errors\n-            if (isFalsy(lhs))\n-            {\n-                lhs = toBool(rhs);\n-                continue;\n-            }\n-            // lhs is non-bool error \u2014 propagate\n-            lhs = Value.err(\"'||' operand is not a bool: \" ~ typeName(lhs));\n-            continue;\n-        }\n-\n-        auto rhs = parseExpr(r, env, ctx, prec + 1);\n-        lhs = evalBinary(tok.kind, lhs, rhs);\n-    }\n-\n-    return lhs;\n-}\n-\n-/// Parse a unary expression (prefix operators and atoms).\n-private Value parseUnary(ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto tok = r.peek();\n-\n-    if (tok.kind == Token.Kind.minus)\n-    {\n-        r.advance();\n-        auto operand = parseUnary(r, env, ctx);\n-        return evalUnaryMinus(operand);\n-    }\n-\n-    if (tok.kind == Token.Kind.bang)\n-    {\n-        r.advance();\n-        auto operand = parseUnary(r, env, ctx);\n-        return evalUnaryNot(operand);\n-    }\n-\n-    return parseAtom(r, env, ctx);\n-}\n-\n-/// Parse an atomic expression (literals, identifiers, parens, lists, maps).\n-private Value parseAtom(ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto tok = r.peek();\n-\n-    switch (tok.kind)\n-    {\n-    case Token.Kind.intLit:\n-        r.advance();\n-        return parseIntLit(tok);\n-\n-    case Token.Kind.uintLit:\n-        r.advance();\n-        return parseUintLit(tok);\n-\n-    case Token.Kind.floatLit:\n-        r.advance();\n-        return parseFloatLit(tok);\n-\n-    case Token.Kind.stringLit:\n-        r.advance();\n-        return Value(parseStringContent(tok.text));\n-\n-    case Token.Kind.bytesLit:\n-        r.advance();\n-        return Value(cast(immutable(ubyte)[]) parseStringContent(tok.text));\n-\n-    case Token.Kind.trueKw:\n-        r.advance();\n-        return Value(true);\n-\n-    case Token.Kind.falseKw:\n-        r.advance();\n-        return Value(false);\n-\n-    case Token.Kind.nullKw:\n-        r.advance();\n-        return Value.null_();\n-\n-    case Token.Kind.ident:\n-        r.advance();\n-        // Function call: ident(args...)\n-        if (r.peek().kind == Token.Kind.lparen)\n-        {\n-            r.advance(); // consume '('\n-            // Check macros first\n-            if (auto m = tok.text in env.macros)\n-            {\n-                return (*m)(r, env, ctx);\n-            }\n-            auto args = parseArgList(r, env, ctx);\n-            r.expect(Token.Kind.rparen);\n-            return evalFunction(tok.text, args, tok.pos);\n-        }\n-        // Variable lookup\n-        return ctx(tok.text);\n-\n-    case Token.Kind.lparen:\n-        r.advance();\n-        auto inner = parseExpr(r, env, ctx, 0);\n-        r.expect(Token.Kind.rparen);\n-        return inner;\n-\n-    case Token.Kind.lbracket:\n-        r.advance();\n-        return parseList(r, env, ctx);\n-\n-    case Token.Kind.lbrace:\n-        r.advance();\n-        return parseMap(r, env, ctx);\n-\n-    default:\n-        throw new EvalException(\"unexpected \" ~ tok.toString(), tok.pos);\n-    }\n-}\n-\n-/// Parse a ternary conditional (after consuming '?').\n-private Value parseTernary(ref TokenRange r, const Env env, Context ctx, Value cond)\n-{\n-    auto thenVal = parseExpr(r, env, ctx, 0);\n-    r.expect(Token.Kind.colon);\n-    auto elseVal = parseExpr(r, env, ctx, 0);\n-    if (cond.type == Value.Type.err)\n-        return cond;\n-    if (cond.type != Value.Type.bool_)\n-        return Value.err(\"ternary condition must be a bool, got \" ~ typeName(cond));\n-    return isTruthy(cond) ? thenVal : elseVal;\n-}\n-\n-/// Parse a comma-separated argument list (without consuming parens).\n-Value[] parseArgList(ref TokenRange r, const Env env, Context ctx)\n-{\n-    Value[] args;\n-    if (r.peek().kind == Token.Kind.rparen)\n-        return args;\n-    args ~= parseExpr(r, env, ctx, 0);\n-    while (r.match(Token.Kind.comma))\n-        args ~= parseExpr(r, env, ctx, 0);\n-    return args;\n-}\n-\n-/// Parse a list literal [...].\n-private Value parseList(ref TokenRange r, const Env env, Context ctx)\n-{\n-    Value[] elems;\n-    if (r.peek().kind == Token.Kind.rbracket)\n-    {\n-        r.advance();\n-        return Value(cast(List) new ArrayList(elems));\n-    }\n-    elems ~= parseExpr(r, env, ctx, 0);\n-    while (r.match(Token.Kind.comma))\n-    {\n-        if (r.peek().kind == Token.Kind.rbracket)\n-            break;\n-        elems ~= parseExpr(r, env, ctx, 0);\n-    }\n-    r.expect(Token.Kind.rbracket);\n-    return Value(cast(List) new ArrayList(elems));\n-}\n-\n-/// Parse a map literal {...}.\n-private Value parseMap(ref TokenRange r, const Env env, Context ctx)\n-{\n-    Value[string] entries;\n-    if (r.peek().kind == Token.Kind.rbrace)\n-    {\n-        r.advance();\n-        return Value(entries);\n-    }\n-\n-    parseMapEntry(r, env, ctx, entries);\n-    while (r.match(Token.Kind.comma))\n-    {\n-        if (r.peek().kind == Token.Kind.rbrace)\n-            break;\n-        parseMapEntry(r, env, ctx, entries);\n-    }\n-    r.expect(Token.Kind.rbrace);\n-    return Value(entries);\n-}\n-\n-private void parseMapEntry(ref TokenRange r, const Env env, Context ctx, ref Value[string] entries)\n-{\n-    auto keyTok = r.peek();\n-    auto keyVal = parseExpr(r, env, ctx, 0);\n-    r.expect(Token.Kind.colon);\n-    auto valExpr = parseExpr(r, env, ctx, 0);\n-\n-    auto keyStr = tryGet!string(keyVal);\n-    if (keyStr.isNull)\n-        throw new EvalException(\"map keys must be strings\", keyTok.pos);\n-    entries[keyStr.get] = valExpr;\n-}\n-\n-// \u2500\u2500 Operator precedence \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-private int infixPrec(Token.Kind kind)\n-{\n-    switch (kind)\n-    {\n-    case Token.Kind.question:\n-        return 1;\n-    case Token.Kind.pipePipe:\n-        return 2;\n-    case Token.Kind.ampAmp:\n-        return 3;\n-    case Token.Kind.eqEq:\n-    case Token.Kind.bangEq:\n-    case Token.Kind.inKw:\n-        return 4;\n-    case Token.Kind.lt:\n-    case Token.Kind.ltEq:\n-    case Token.Kind.gt:\n-    case Token.Kind.gtEq:\n-        return 5;\n-    case Token.Kind.plus:\n-    case Token.Kind.minus:\n-        return 6;\n-    case Token.Kind.star:\n-    case Token.Kind.slash:\n-    case Token.Kind.percent:\n-        return 7;\n-    case Token.Kind.dot:\n-    case Token.Kind.lbracket:\n-        return 8;\n-    default:\n-        return -1;\n-    }\n-}\n-\n-// \u2500\u2500 Evaluation helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-private bool isErr(Value v)\n-{\n-    return v.type == Value.Type.err;\n-}\n-\n-/// Cross-type int\u00d7uint comparison helper.\n-/// Compares a long against a ulong for ordering operators.\n-/// When `swapped` is true, the original order was (uint, int) so comparison\n-/// direction must be reversed.\n-private Value crossCompare(long intVal, ulong uintVal, Token.Kind op, bool swapped)\n-{\n-    // Determine the relationship: intVal vs uintVal\n-    bool intLess;\n-    bool equal;\n-    if (intVal < 0)\n-    {\n-        intLess = true;\n-        equal = false;\n-    }\n-    else\n-    {\n-        auto asUlong = cast(ulong) intVal;\n-        intLess = asUlong < uintVal;\n-        equal = asUlong == uintVal;\n-    }\n-\n-    // Without swap: expression is (int OP uint), so intLess means \"lhs < rhs\"\n-    // With swap: expression was (uint OP int), so we reverse the sense\n-    bool lhsLess = swapped ? (!intLess && !equal) : intLess;\n-    bool lhsEqual = equal;\n-\n-    switch (op)\n-    {\n-    case Token.Kind.lt:\n-        return Value(lhsLess);\n-    case Token.Kind.ltEq:\n-        return Value(lhsLess || lhsEqual);\n-    case Token.Kind.gt:\n-        return Value(!lhsLess && !lhsEqual);\n-    case Token.Kind.gtEq:\n-        return Value(!lhsLess);\n-    default:\n-        return Value.err(\"unsupported comparison operator for int/uint\");\n-    }\n-}\n-\n-/// Cross-type int\u00d7uint binary operation.\n-/// When `swapped` is true, the original order was (uint, int) so comparison\n-/// direction must be reversed.\n-private Value crossNumericOp(long intVal, ulong uintVal, Token.Kind op, bool swapped = false)\n-{\n-    switch (op)\n-    {\n-    case Token.Kind.eqEq:\n-        if (intVal < 0)\n-            return Value(false);\n-        return Value(cast(ulong) intVal == uintVal);\n-    case Token.Kind.bangEq:\n-        if (intVal < 0)\n-            return Value(true);\n-        return Value(cast(ulong) intVal != uintVal);\n-    case Token.Kind.lt:\n-    case Token.Kind.ltEq:\n-    case Token.Kind.gt:\n-    case Token.Kind.gtEq:\n-        return crossCompare(intVal, uintVal, op, swapped);\n-        // Arithmetic: promote uint to long\n-    case Token.Kind.plus:\n-    case Token.Kind.minus:\n-    case Token.Kind.star:\n-    case Token.Kind.slash:\n-    case Token.Kind.percent:\n-        if (uintVal > cast(ulong) long.max)\n-            return Value.err(\"uint value too large for int arithmetic\");\n-        if (swapped)\n-            return numericBinop!long(cast(long) uintVal, intVal, op);\n-        return numericBinop!long(intVal, cast(long) uintVal, op);\n-    default:\n-        return Value.err(\"unsupported operator for int/uint\");\n-    }\n-}\n-\n-/// Dispatch a binary op over two numeric values of the same type.\n-/// Handles arithmetic (+, -, *, /, %) and comparison (<, <=, >, >=, ==, !=).\n-private Value numericBinop(T)(T l, T r, Token.Kind op)\n-{\n-    switch (op)\n-    {\n-    case Token.Kind.plus:\n-        return Value(l + r);\n-    case Token.Kind.minus:\n-        return Value(l - r);\n-    case Token.Kind.star:\n-        return Value(l * r);\n-    case Token.Kind.slash:\n-        static if (is(T == double))\n-            return Value(l / r);\n-        else\n-        {\n-            if (r == 0)\n-                return Value.err(\"division by zero\");\n-            return Value(l / r);\n-        }\n-    case Token.Kind.percent:\n-        static if (is(T == double))\n-            return Value(l % r);\n-        else\n-        {\n-            if (r == 0)\n-                return Value.err(\"modulo by zero\");\n-            return Value(l % r);\n-        }\n-    case Token.Kind.eqEq:\n-        return Value(l == r);\n-    case Token.Kind.bangEq:\n-        return Value(l != r);\n-    case Token.Kind.lt:\n-        return Value(l < r);\n-    case Token.Kind.ltEq:\n-        return Value(l <= r);\n-    case Token.Kind.gt:\n-        return Value(l > r);\n-    case Token.Kind.gtEq:\n-        return Value(l >= r);\n-    default:\n-        return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for numeric types\");\n-    }\n-}\n-\n-private Value evalBinary(Token.Kind op, Value lhs, Value rhs)\n-{\n-    if (isErr(lhs))\n-        return lhs;\n-    if (isErr(rhs))\n-        return rhs;\n-\n-    // Entry.asValue() unwrapping \u2014 let entries participate in binary ops\n-    lhs = unwrapEntry(lhs);\n-    rhs = unwrapEntry(rhs);\n-\n-    // Null equality: null == null \u2192 true, null != X \u2192 true\n-    if (lhs.type == Value.Type.null_ || rhs.type == Value.Type.null_)\n-    {\n-        if (op == Token.Kind.eqEq)\n-            return Value(lhs.type == Value.Type.null_ && rhs.type == Value.Type.null_);\n-        if (op == Token.Kind.bangEq)\n-            return Value(lhs.type != Value.Type.null_ || rhs.type != Value.Type.null_);\n-        return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for null\");\n-    }\n-\n-    // Try each numeric type pair via static foreach.\n-    alias NumericTypes = imported!\"std.meta\".AliasSeq!(long, ulong);\n-    static foreach (T; NumericTypes)\n-    {\n-        {\n-            auto l = tryGet!T(lhs);\n-            auto r = tryGet!T(rhs);\n-            if (!l.isNull && !r.isNull)\n-                return numericBinop!T(l.get, r.get, op);\n-        }\n-    }\n-\n-    // Cross-type int\u00d7uint dispatch\n-    {\n-        auto li = tryGet!long(lhs);\n-        auto ru = tryGet!ulong(rhs);\n-        if (!li.isNull && !ru.isNull)\n-            return crossNumericOp(li.get, ru.get, op);\n-    }\n-    {\n-        auto lu = tryGet!ulong(lhs);\n-        auto ri = tryGet!long(rhs);\n-        if (!lu.isNull && !ri.isNull)\n-            return crossNumericOp(ri.get, lu.get, op, true); // swapped\n-    }\n-\n-    // Duration binary ops: duration \u00b1 duration, duration comparison\n-    {\n-        auto ldur = tryGet!Duration(lhs);\n-        auto rdur = tryGet!Duration(rhs);\n-        if (!ldur.isNull && !rdur.isNull)\n-            return evalDurationBinary(ldur.get, rdur.get, op);\n-    }\n-\n-    // Timestamp binary ops: ts - ts, ts \u00b1 dur, dur + ts, ts comparison\n-    if (lhs.type == Value.Type.timestamp || rhs.type == Value.Type.timestamp)\n-        return evalTimestampBinary(op, lhs, rhs);\n-\n-    // Double (with int/uint promotion)\n-    auto ld = toDouble(lhs);\n-    auto rd = toDouble(rhs);\n-    if (!ld.isNull && !rd.isNull)\n-        return numericBinop!double(ld.get, rd.get, op);\n-\n-    // String concatenation and comparison\n-    auto ls = tryGet!string(lhs);\n-    auto rs = tryGet!string(rhs);\n-    if (!ls.isNull && !rs.isNull)\n-    {\n-        switch (op)\n-        {\n-        case Token.Kind.plus:\n-            return Value(ls.get ~ rs.get);\n-        case Token.Kind.eqEq:\n-            return Value(ls.get == rs.get);\n-        case Token.Kind.bangEq:\n-            return Value(ls.get != rs.get);\n-        case Token.Kind.lt:\n-            return Value(ls.get < rs.get);\n-        case Token.Kind.ltEq:\n-            return Value(ls.get <= rs.get);\n-        case Token.Kind.gt:\n-            return Value(ls.get > rs.get);\n-        case Token.Kind.gtEq:\n-            return Value(ls.get >= rs.get);\n-        default:\n-            break;\n-        }\n-    }\n-\n-    // Bool equality\n-    auto lb = tryGet!bool(lhs);\n-    auto rb = tryGet!bool(rhs);\n-    if (!lb.isNull && !rb.isNull)\n-    {\n-        switch (op)\n-        {\n-        case Token.Kind.eqEq:\n-            return Value(lb.get == rb.get);\n-        case Token.Kind.bangEq:\n-            return Value(lb.get != rb.get);\n-        default:\n-            break;\n-        }\n-    }\n-\n-    // List concatenation\n-    auto ll = tryGet!List(lhs);\n-    auto rl = tryGet!List(rhs);\n-    if (!ll.isNull && !rl.isNull)\n-    {\n-        if (op == Token.Kind.plus)\n-        {\n-            Value[] combined;\n-            auto left = ll.get;\n-            foreach (i; 0 .. left.length)\n-                combined ~= left.index(i);\n-            auto right = rl.get;\n-            foreach (i; 0 .. right.length)\n-                combined ~= right.index(i);\n-            return Value(cast(List) new ArrayList(combined));\n-        }\n-    }\n-\n-    return Value.err(\"unsupported operator \" ~ kindName(\n-            op) ~ \" for types \" ~ typeName(lhs) ~ \" and \" ~ typeName(rhs));\n-}\n-\n-private Value evalUnaryMinus(Value operand)\n-{\n-    if (isErr(operand))\n-        return operand;\n-    operand = unwrapEntry(operand);\n-    auto i = tryGet!long(operand);\n-    if (!i.isNull)\n-        return Value(-i.get);\n-    auto u = tryGet!ulong(operand);\n-    if (!u.isNull)\n-        return Value(-cast(long) u.get);\n-    auto d = tryGet!double(operand);\n-    if (!d.isNull)\n-        return Value(-d.get);\n-    return Value.err(\"cannot negate \" ~ typeName(operand));\n-}\n-\n-private Value evalUnaryNot(Value operand)\n-{\n-    if (isErr(operand))\n-        return operand;\n-    operand = unwrapEntry(operand);\n-    auto b = tryGet!bool(operand);\n-    if (!b.isNull)\n-        return Value(!b.get);\n-    return Value.err(\"cannot apply ! to \" ~ typeName(operand));\n-}\n-\n-private Value evalIn(Value lhs, Value rhs)\n-{\n-    if (isErr(lhs))\n-        return lhs;\n-    if (isErr(rhs))\n-        return rhs;\n-\n-    auto ls = tryGet!string(lhs);\n-    auto rs = tryGet!string(rhs);\n-    if (!ls.isNull && !rs.isNull)\n-    {\n-        import std.algorithm : canFind;\n-\n-        return Value(rs.get.canFind(ls.get));\n-    }\n-\n-    auto rl = tryGet!List(rhs);\n-    if (!rl.isNull)\n-    {\n-        auto list = rl.get;\n-        foreach (i; 0 .. list.length)\n-            if (list.index(i) == lhs)\n-                return Value(true);\n-        return Value(false);\n-    }\n-\n-    auto rm = tryGet!(Value[string])(rhs);\n-    if (!rm.isNull && !ls.isNull)\n-    {\n-        return Value((ls.get in rm.get) !is null);\n-    }\n-\n-    // Entry.asList() fallback for list membership\n-    auto re = tryGet!Entry(rhs);\n-    if (!re.isNull)\n-    {\n-        auto el = re.get.asList();\n-        if (el !is null)\n-        {\n-            foreach (i; 0 .. el.length)\n-                if (el.index(i) == lhs)\n-                    return Value(true);\n-            return Value(false);\n-        }\n-    }\n-\n-    return Value.err(\"unsupported 'in' for types \" ~ typeName(lhs) ~ \" and \" ~ typeName(rhs));\n-}\n-\n-private Value evalMember(Value obj, string name)\n-{\n-    if (isErr(obj))\n-        return obj;\n-\n-    const m = tryGet!(Value[string])(obj);\n-    if (!m.isNull)\n-    {\n-        if (auto p = name in m.get)\n-            return *p;\n-        return Value.err(\"no such key: \" ~ name);\n-    }\n-    auto e = tryGet!Entry(obj);\n-    if (!e.isNull)\n-        return e.get.resolve(name);\n-    return Value.err(\"cannot access member '\" ~ name ~ \"' on \" ~ typeName(obj));\n-}\n-\n-private Value evalIndex(Value obj, Value index)\n-{\n-    if (isErr(obj))\n-        return obj;\n-    if (isErr(index))\n-        return index;\n-\n-    auto listVal = tryGet!List(obj);\n-    auto idxVal = tryGet!long(index);\n-    if (!listVal.isNull && !idxVal.isNull)\n-    {\n-        auto list = listVal.get;\n-        auto idx = idxVal.get;\n-        if (idx < 0)\n-            idx += cast(long) list.length;\n-        if (idx < 0 || idx >= cast(long) list.length)\n-            return Value.err(\"index out of range\");\n-        return list.index(cast(size_t) idx);\n-    }\n-\n-    const im = tryGet!(Value[string])(obj);\n-    auto ik = tryGet!string(index);\n-    if (!im.isNull && !ik.isNull)\n-    {\n-        if (auto p = ik.get in im.get)\n-            return *p;\n-        return Value.err(\"no such key: \" ~ ik.get);\n-    }\n-\n-    // Entry.asList() fallback for integer indexing\n-    if (!idxVal.isNull)\n-    {\n-        auto entryVal = tryGet!Entry(obj);\n-        if (!entryVal.isNull)\n-        {\n-            auto el = entryVal.get.asList();\n-            if (el !is null)\n-            {\n-                auto idx = idxVal.get;\n-                if (idx < 0)\n-                    idx += cast(long) el.length;\n-                if (idx < 0 || idx >= cast(long) el.length)\n-                    return Value.err(\"index out of range\");\n-                return el.index(cast(size_t) idx);\n-            }\n-        }\n-    }\n-\n-    // Entry string-key indexing (like map access)\n-    if (!ik.isNull)\n-    {\n-        auto entryVal = tryGet!Entry(obj);\n-        if (!entryVal.isNull)\n-            return entryVal.get.resolve(ik.get);\n-    }\n-\n-    return Value.err(\"cannot index \" ~ typeName(obj));\n-}\n-\n-private Value evalFunction(string name, Value[] args, size_t pos)\n-{\n-    switch (name)\n-    {\n-    case \"size\":\n-        if (args.length != 1)\n-            throw new EvalException(\"size() takes exactly 1 argument\", pos);\n-        return evalSize(args[0]);\n-    case \"type\":\n-        if (args.length != 1)\n-            throw new EvalException(\"type() takes exactly 1 argument\", pos);\n-        if (isErr(args[0]))\n-            return args[0];\n-        return Value(typeName(args[0]));\n-    case \"int\":\n-        if (args.length != 1)\n-            throw new EvalException(\"int() takes exactly 1 argument\", pos);\n-        return evalNumericCast!long(args[0], \"int\");\n-    case \"uint\":\n-        if (args.length != 1)\n-            throw new EvalException(\"uint() takes exactly 1 argument\", pos);\n-        return evalNumericCast!ulong(args[0], \"uint\");\n-    case \"double\":\n-        if (args.length != 1)\n-            throw new EvalException(\"double() takes exactly 1 argument\", pos);\n-        return evalNumericCast!double(args[0], \"double\");\n-    case \"string\":\n-        if (args.length != 1)\n-            throw new EvalException(\"string() takes exactly 1 argument\", pos);\n-        return evalStringCast(args[0]);\n-    case \"duration\":\n-        if (args.length != 1)\n-            throw new EvalException(\"duration() takes exactly 1 argument\", pos);\n-        return evalDurationCast(args[0]);\n-    case \"timestamp\":\n-        if (args.length != 1)\n-            throw new EvalException(\"timestamp() takes exactly 1 argument\", pos);\n-        return evalTimestampCast(args[0]);\n-    case \"now\":\n-        if (args.length != 0)\n-            throw new EvalException(\"now() takes no arguments\", pos);\n-        import std.datetime.systime : Clock;\n-\n-        return Value(Clock.currTime(UTC()));\n-    default:\n-        throw new EvalException(\"unknown function: \" ~ name, pos);\n-    }\n-}\n-\n-private Value evalMethod(Value obj, string name, Value[] args)\n-{\n-    if (isErr(obj))\n-        return obj;\n-\n-    switch (name)\n-    {\n-    case \"size\":\n-        if (args.length != 0)\n-            return Value.err(\".size() takes no arguments\");\n-        return evalSize(obj);\n-    case \"contains\":\n-        if (args.length != 1)\n-            return Value.err(\".contains() takes exactly 1 argument\");\n-        return evalStringMethod(\"contains\", obj, args[0], (s, a) {\n-            import std.algorithm : canFind;\n-\n-            return s.canFind(a);\n-        });\n-    case \"startsWith\":\n-        if (args.length != 1)\n-            return Value.err(\".startsWith() takes exactly 1 argument\");\n-        return evalStringMethod(\"startsWith\", obj, args[0], (s, a) {\n-            import std.algorithm : startsWith;\n-\n-            return s.startsWith(a);\n-        });\n-    case \"endsWith\":\n-        if (args.length != 1)\n-            return Value.err(\".endsWith() takes exactly 1 argument\");\n-        return evalStringMethod(\"endsWith\", obj, args[0], (s, a) {\n-            import std.algorithm : endsWith;\n-\n-            return s.endsWith(a);\n-        });\n-    case \"matches\":\n-        if (args.length != 1)\n-            return Value.err(\".matches() takes exactly 1 argument\");\n-        return evalMatches(obj, args[0]);\n-    default:\n-        break;\n-    }\n-\n-    // Duration accessor methods\n-    auto durVal = tryGet!Duration(obj);\n-    if (!durVal.isNull)\n-        return evalDurationMethod(durVal.get, name, args);\n-\n-    // Timestamp accessor methods\n-    auto tsVal = tryGet!SysTime(obj);\n-    if (!tsVal.isNull)\n-        return evalTimestampMethod(tsVal.get, name, args);\n-\n-    return Value.err(\"unknown method: \" ~ name);\n-}\n-\n-// \u2500\u2500 Built-in function implementations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-private Value evalSize(Value v)\n-{\n-    if (isErr(v))\n-        return v;\n-    auto s = tryGet!string(v);\n-    if (!s.isNull)\n-        return Value(cast(long) s.get.length);\n-    auto b = tryGet!(immutable(ubyte)[])(v);\n-    if (!b.isNull)\n-        return Value(cast(long) b.get.length);\n-    auto l = tryGet!List(v);\n-    if (!l.isNull)\n-        return Value(cast(long) l.get.length);\n-    auto m = tryGet!(Value[string])(v);\n-    if (!m.isNull)\n-        return Value(cast(long) m.get.length);\n-    // Entry.asList() fallback\n-    auto e = tryGet!Entry(v);\n-    if (!e.isNull)\n-    {\n-        auto el = e.get.asList();\n-        if (el !is null)\n-            return Value(cast(long) el.length);\n-    }\n-    return Value.err(\"size() not supported for \" ~ typeName(v));\n-}\n-\n-/// Shared implementation for binary string methods (.contains, .startsWith, .endsWith).\n-private Value evalStringMethod(string name, Value obj, Value arg, bool delegate(string, string) fn)\n-{\n-    if (isErr(obj))\n-        return obj;\n-    if (isErr(arg))\n-        return arg;\n-    auto s = tryGet!string(obj);\n-    auto a = tryGet!string(arg);\n-    if (!s.isNull && !a.isNull)\n-        return Value(fn(s.get, a.get));\n-    return Value.err(\".\" ~ name ~ \"() requires string arguments\");\n-}\n-\n-private Value evalMatches(Value obj, Value arg)\n-{\n-    import std.regex : regex, matchFirst, RegexException;\n-\n-    if (isErr(obj))\n-        return obj;\n-    if (isErr(arg))\n-        return arg;\n-    auto s = tryGet!string(obj);\n-    auto pat = tryGet!string(arg);\n-    if (s.isNull || pat.isNull)\n-        return Value.err(\".matches() requires string arguments\");\n-\n-    // CEL .matches() checks if the entire string matches the regex.\n-    // Anchor the pattern to enforce full-string matching.\n-    string anchored = \"^(?:\" ~ pat.get ~ \")$\";\n-\n-    try\n-    {\n-        auto re = regex(anchored);\n-        auto m = matchFirst(s.get, re);\n-        return Value(!m.empty);\n-    }\n-    catch (RegexException e)\n-    {\n-        return Value.err(\"invalid regex: \" ~ e.msg);\n-    }\n-}\n-\n-/// Generic numeric cast: int(), uint(), double().\n-/// Tries direct match, cross-numeric casts, then string parsing.\n-private Value evalNumericCast(T)(Value v, string targetName)\n-{\n-    if (isErr(v))\n-        return v;\n-    // Direct match \u2014 no conversion needed.\n-    auto direct = tryGet!T(v);\n-    if (!direct.isNull)\n-        return Value(direct.get);\n-    // Cross-numeric casts.\n-    auto i = tryGet!long(v);\n-    if (!i.isNull)\n-        return Value(cast(T) i.get);\n-    auto u = tryGet!ulong(v);\n-    if (!u.isNull)\n-        return Value(cast(T) u.get);\n-    auto d = tryGet!double(v);\n-    if (!d.isNull)\n-        return Value(cast(T) d.get);\n-    // String parsing.\n-    auto s = tryGet!string(v);\n-    if (!s.isNull)\n-    {\n-        try\n-            return Value(s.get.to!T);\n-        catch (ConvException)\n-            return Value.err(\"cannot convert string to \" ~ targetName ~ \": \" ~ s.get);\n-    }\n-    return Value.err(\"cannot convert \" ~ typeName(v) ~ \" to \" ~ targetName);\n-}\n-\n-private Value evalStringCast(Value v)\n-{\n-    if (isErr(v))\n-        return v;\n-    auto s = tryGet!string(v);\n-    if (!s.isNull)\n-        return Value(s.get);\n-    auto i = tryGet!long(v);\n-    if (!i.isNull)\n-        return Value(i.get.to!string);\n-    auto u = tryGet!ulong(v);\n-    if (!u.isNull)\n-        return Value(u.get.to!string);\n-    auto d = tryGet!double(v);\n-    if (!d.isNull)\n-        return Value(d.get.to!string);\n-    auto b = tryGet!bool(v);\n-    if (!b.isNull)\n-        return Value(b.get ? \"true\" : \"false\");\n-    auto dur = tryGet!Duration(v);\n-    if (!dur.isNull)\n-        return Value(formatISO8601Duration(dur.get));\n-    auto ts = tryGet!SysTime(v);\n-    if (!ts.isNull)\n-        return Value(formatRFC3339(ts.get));\n-    return Value.err(\"cannot convert \" ~ typeName(v) ~ \" to string\");\n-}\n-\n-// \u2500\u2500 Duration / Timestamp evaluation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-private Value evalDurationCast(Value v)\n-{\n-    if (isErr(v))\n-        return v;\n-    auto d = tryGet!Duration(v);\n-    if (!d.isNull)\n-        return Value(d.get);\n-    auto s = tryGet!string(v);\n-    if (!s.isNull)\n-    {\n-        auto parsed = parseISO8601Duration(s.get);\n-        if (parsed.isNull)\n-            return Value.err(\"invalid duration string: \" ~ s.get);\n-        return Value(parsed.get);\n-    }\n-    return Value.err(\"cannot convert \" ~ typeName(v) ~ \" to duration\");\n-}\n-\n-private Value evalTimestampCast(Value v)\n-{\n-    if (isErr(v))\n-        return v;\n-    auto t = tryGet!SysTime(v);\n-    if (!t.isNull)\n-        return Value(t.get);\n-    auto s = tryGet!string(v);\n-    if (!s.isNull)\n-    {\n-        auto parsed = parseRFC3339(s.get);\n-        if (parsed.isNull)\n-            return Value.err(\"invalid timestamp string: \" ~ s.get);\n-        return Value(parsed.get);\n-    }\n-    return Value.err(\"cannot convert \" ~ typeName(v) ~ \" to timestamp\");\n-}\n-\n-/// Duration binary operations: duration \u00b1 duration, duration == duration, duration <=> duration.\n-private Value evalDurationBinary(Duration ld, Duration rd, Token.Kind op)\n-{\n-    switch (op)\n-    {\n-    case Token.Kind.plus:\n-        return Value(ld + rd);\n-    case Token.Kind.minus:\n-        return Value(ld - rd);\n-    case Token.Kind.eqEq:\n-        return Value(ld == rd);\n-    case Token.Kind.bangEq:\n-        return Value(ld != rd);\n-    case Token.Kind.lt:\n-        return Value(ld < rd);\n-    case Token.Kind.ltEq:\n-        return Value(ld <= rd);\n-    case Token.Kind.gt:\n-        return Value(ld > rd);\n-    case Token.Kind.gtEq:\n-        return Value(ld >= rd);\n-    default:\n-        return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for duration\");\n-    }\n-}\n-\n-/// Timestamp binary operations: ts - ts \u2192 duration, ts \u00b1 duration \u2192 ts, ts <=> ts.\n-private Value evalTimestampBinary(Token.Kind op, Value lhs, Value rhs)\n-{\n-    auto lt = tryGet!SysTime(lhs);\n-    auto rt = tryGet!SysTime(rhs);\n-\n-    // timestamp - timestamp \u2192 duration\n-    if (!lt.isNull && !rt.isNull)\n-    {\n-        switch (op)\n-        {\n-        case Token.Kind.minus:\n-            return Value(lt.get - rt.get);\n-        case Token.Kind.eqEq:\n-            return Value(lt.get == rt.get);\n-        case Token.Kind.bangEq:\n-            return Value(lt.get != rt.get);\n-        case Token.Kind.lt:\n-            return Value(lt.get < rt.get);\n-        case Token.Kind.ltEq:\n-            return Value(lt.get <= rt.get);\n-        case Token.Kind.gt:\n-            return Value(lt.get > rt.get);\n-        case Token.Kind.gtEq:\n-            return Value(lt.get >= rt.get);\n-        default:\n-            return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for timestamps\");\n-        }\n-    }\n-\n-    // timestamp \u00b1 duration \u2192 timestamp\n-    if (!lt.isNull)\n-    {\n-        auto rd = tryGet!Duration(rhs);\n-        if (!rd.isNull)\n-        {\n-            if (op == Token.Kind.plus)\n-                return Value(lt.get + rd.get);\n-            if (op == Token.Kind.minus)\n-                return Value(lt.get - rd.get);\n-            return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for timestamp and duration\");\n-        }\n-    }\n-\n-    // duration + timestamp \u2192 timestamp\n-    auto ld = tryGet!Duration(lhs);\n-    if (!ld.isNull && !rt.isNull)\n-    {\n-        if (op == Token.Kind.plus)\n-            return Value(rt.get + ld.get);\n-        return Value.err(\"unsupported operator \" ~ kindName(op) ~ \" for duration and timestamp\");\n-    }\n-\n-    return Value.err(\"unsupported operand types for \" ~ kindName(op));\n-}\n-\n-/// Duration accessor methods.\n-private Value evalDurationMethod(Duration d, string name, Value[] args)\n-{\n-    if (args.length != 0)\n-        return Value.err(\".\" ~ name ~ \"() takes no arguments\");\n-    switch (name)\n-    {\n-    case \"hours\":\n-        return Value(d.total!\"hours\");\n-    case \"minutes\":\n-        return Value(d.total!\"minutes\");\n-    case \"seconds\":\n-        return Value(d.total!\"seconds\");\n-    default:\n-        return Value.err(\"unknown duration method: \" ~ name);\n-    }\n-}\n-\n-/// Timestamp accessor methods.\n-private Value evalTimestampMethod(SysTime st, string name, Value[] args)\n-{\n-    if (args.length != 0)\n-        return Value.err(\".\" ~ name ~ \"() takes no arguments\");\n-    auto utc = st.toUTC();\n-    switch (name)\n-    {\n-    case \"year\":\n-        return Value(cast(long) utc.year);\n-    case \"month\":\n-        return Value(cast(long) cast(int) utc.month);\n-    case \"day\":\n-        return Value(cast(long) utc.day);\n-    case \"hour\":\n-        return Value(cast(long) utc.hour);\n-    case \"minute\":\n-        return Value(cast(long) utc.minute);\n-    case \"second\":\n-        return Value(cast(long) utc.second);\n-    case \"dayOfWeek\":\n-        return Value(cast(long) cast(int) utc.dayOfWeek);\n-    case \"dayOfYear\":\n-        return Value(cast(long) utc.dayOfYear);\n-    default:\n-        return Value.err(\"unknown timestamp method: \" ~ name);\n-    }\n-}\n-\n-// \u2500\u2500 Macros \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-/// Built-in macros that ship with every evaluator.\n-Macro[string] builtinMacros()\n-{\n-    Macro[string] m;\n-    m[\"has\"] = (ref TokenRange r, const Env env, Context ctx) => macroHas(r, env, ctx);\n-    return m;\n-}\n-\n-/// Built-in method macros for comprehensions.\n-MethodMacro[string] builtinMethodMacros()\n-{\n-    MethodMacro[string] m;\n-    m[\"all\"] = (Value t, ref TokenRange r, const Env env, Context ctx) => macroAll(t, r, env, ctx);\n-    m[\"exists\"] = (Value t, ref TokenRange r, const Env env, Context ctx) => macroExists(t,\n-            r, env, ctx);\n-    m[\"exists_one\"] = (Value t, ref TokenRange r, const Env env, Context ctx) => macroExistsOne(t,\n-            r, env, ctx);\n-    m[\"map\"] = (Value t, ref TokenRange r, const Env env, Context ctx) => macroMap(t, r, env, ctx);\n-    m[\"filter\"] = (Value t, ref TokenRange r, const Env env, Context ctx) => macroFilter(t,\n-            r, env, ctx);\n-    return m;\n-}\n-\n-/// Parsed comprehension: binder name and body token range.\n-private struct ComprehensionArgs\n-{\n-    /// Name of the iteration variable.\n-    string binder;\n-    /// Token position where the body expression starts.\n-    size_t bodyStart;\n-    /// Token position after the body expression.\n-    size_t bodyEnd;\n-}\n-\n-/// Parse comprehension arguments: binder, comma, body expression.\n-/// Uses a probe sub-range with binder=null to find where the body ends.\n-private ComprehensionArgs parseComprehensionArgs(ref TokenRange r, const Env env, Context ctx)\n-{\n-    ComprehensionArgs args;\n-    auto binderTok = r.expect(Token.Kind.ident);\n-    args.binder = binderTok.text;\n-    r.expect(Token.Kind.comma);\n-    args.bodyStart = r.pos;\n-    // Probe: parse body with null binder to find extent\n-    auto probe = r.save();\n-    auto nullCtx = bindContext(ctx, args.binder, Value.null_());\n-    parseExpr(probe, env, nullCtx, 0);\n-    args.bodyEnd = probe.pos;\n-    // Advance main range to match\n-    r.pos = args.bodyEnd;\n-    r.expect(Token.Kind.rparen);\n-    return args;\n-}\n-\n-/// Evaluate a comprehension body with a binder bound to element.\n-/// Creates a sub-range, parses, and asserts it lands at the expected end.\n-private Value evalBody(ref TokenRange r, const Env env, Context ctx,\n-        ComprehensionArgs args, Value element)\n-{\n-    auto sub = r.save();\n-    sub.pos = args.bodyStart;\n-    auto innerCtx = bindContext(ctx, args.binder, element);\n-    auto result = parseExpr(sub, env, innerCtx, 0);\n-    assert(sub.pos == args.bodyEnd, \"comprehension body consumed different tokens on replay\");\n-    return result;\n-}\n-\n-/// Extract a List from a comprehension target, consuming args on error.\n-/// Returns null on error (caller should return the appropriate error Value).\n-/// Also checks Entry.asList() for entries that double as lists.\n-private Nullable!List extractListTarget(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    if (isErr(target))\n-    {\n-        cast(void) parseComprehensionArgs(r, env, ctx);\n-        return Nullable!List.init;\n-    }\n-    auto list = tryGet!List(target);\n-    if (!list.isNull)\n-        return list;\n-    // Entry.asList() fallback\n-    auto entry = tryGet!Entry(target);\n-    if (!entry.isNull)\n-    {\n-        auto el = entry.get.asList();\n-        if (el !is null)\n-            return nullable(el);\n-    }\n-    cast(void) parseComprehensionArgs(r, env, ctx);\n-    return Nullable!List.init;\n-}\n-\n-/// `has(expr)` \u2014 true if expr doesn't produce an error.\n-private Value macroHas(ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto arg = parseExpr(r, env, ctx, 0);\n-    r.expect(Token.Kind.rparen);\n-    return Value(arg.type != Value.Type.err);\n-}\n-\n-/// `list.all(x, body)` \u2014 true if body is true for all elements.\n-private Value macroAll(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto list = extractListTarget(target, r, env, ctx);\n-    if (list.isNull)\n-        return isErr(target) ? target : Value.err(\".all() requires a list\");\n-\n-    auto args = parseComprehensionArgs(r, env, ctx);\n-    auto lt = list.get;\n-    foreach (i; 0 .. lt.length)\n-    {\n-        auto result = evalBody(r, env, ctx, args, lt.index(i));\n-        if (isErr(result))\n-            return result;\n-        if (isFalsy(result))\n-            return Value(false);\n-    }\n-    return Value(true);\n-}\n-\n-/// `list.exists(x, body)` \u2014 true if body is true for at least one element.\n-private Value macroExists(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto list = extractListTarget(target, r, env, ctx);\n-    if (list.isNull)\n-        return isErr(target) ? target : Value.err(\".exists() requires a list\");\n-\n-    auto args = parseComprehensionArgs(r, env, ctx);\n-    auto lt = list.get;\n-    foreach (i; 0 .. lt.length)\n-    {\n-        auto result = evalBody(r, env, ctx, args, lt.index(i));\n-        if (isErr(result))\n-            return result;\n-        if (isTruthy(result))\n-            return Value(true);\n-    }\n-    return Value(false);\n-}\n-\n-/// `list.exists_one(x, body)` \u2014 true if body is true for exactly one element.\n-private Value macroExistsOne(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto list = extractListTarget(target, r, env, ctx);\n-    if (list.isNull)\n-        return isErr(target) ? target : Value.err(\".exists_one() requires a list\");\n-\n-    auto args = parseComprehensionArgs(r, env, ctx);\n-    auto lt = list.get;\n-    int count = 0;\n-    foreach (i; 0 .. lt.length)\n-    {\n-        auto result = evalBody(r, env, ctx, args, lt.index(i));\n-        if (isErr(result))\n-            return result;\n-        if (isTruthy(result))\n-            count++;\n-        if (count > 1)\n-            return Value(false);\n-    }\n-    return Value(count == 1);\n-}\n-\n-/// `list.map(x, body)` \u2014 transform each element.\n-private Value macroMap(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto list = extractListTarget(target, r, env, ctx);\n-    if (list.isNull)\n-        return isErr(target) ? target : Value.err(\".map() requires a list\");\n-\n-    auto args = parseComprehensionArgs(r, env, ctx);\n-    auto lt = list.get;\n-    Value[] result;\n-    foreach (i; 0 .. lt.length)\n-    {\n-        auto mapped = evalBody(r, env, ctx, args, lt.index(i));\n-        if (isErr(mapped))\n-            return mapped;\n-        result ~= mapped;\n-    }\n-    return Value(cast(List) new ArrayList(result));\n-}\n-\n-/// `list.filter(x, body)` \u2014 keep elements where body is true.\n-private Value macroFilter(Value target, ref TokenRange r, const Env env, Context ctx)\n-{\n-    auto list = extractListTarget(target, r, env, ctx);\n-    if (list.isNull)\n-        return isErr(target) ? target : Value.err(\".filter() requires a list\");\n-\n-    auto args = parseComprehensionArgs(r, env, ctx);\n-    auto lt = list.get;\n-    Value[] result;\n-    foreach (i; 0 .. lt.length)\n-    {\n-        auto pred = evalBody(r, env, ctx, args, lt.index(i));\n-        if (isErr(pred))\n-            return pred;\n-        if (isTruthy(pred))\n-            result ~= lt.index(i);\n-    }\n-    return Value(cast(List) new ArrayList(result));\n-}\n-\n-// \u2500\u2500 Literal parsing helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-private Value parseIntLit(Token tok)\n-{\n-    try\n-    {\n-        if (tok.text.length > 2 && tok.text[0] == '0' && (tok.text[1] == 'x' || tok.text[1] == 'X'))\n-            return Value(tok.text[2 .. $].to!long(16));\n-        return Value(tok.text.to!long);\n-    }\n-    catch (ConvException)\n-    {\n-        throw new EvalException(\"invalid integer literal: \" ~ tok.text, tok.pos);\n-    }\n-}\n-\n-private Value parseUintLit(Token tok)\n-{\n-    try\n-    {\n-        auto text = tok.text[0 .. $ - 1]; // strip 'u'/'U' suffix\n-        if (text.length > 2 && text[0] == '0' && (text[1] == 'x' || text[1] == 'X'))\n-            return Value(text[2 .. $].to!ulong(16));\n-        return Value(text.to!ulong);\n-    }\n-    catch (ConvException)\n-    {\n-        throw new EvalException(\"invalid uint literal: \" ~ tok.text, tok.pos);\n-    }\n-}\n-\n-private Value parseFloatLit(Token tok)\n-{\n-    try\n-    {\n-        return Value(tok.text.to!double);\n-    }\n-    catch (ConvException)\n-    {\n-        throw new EvalException(\"invalid float literal: \" ~ tok.text, tok.pos);\n-    }\n-}\n-\n-private string parseStringContent(string raw)\n-{\n-    size_t prefixLen = 0;\n-    bool isRaw = false;\n-    foreach (idx, c; raw)\n-    {\n-        if (c == '\"' || c == '\\'')\n-        {\n-            prefixLen = idx;\n-            break;\n-        }\n-        if (c == 'r' || c == 'R')\n-            isRaw = true;\n-    }\n-\n-    auto rest = raw[prefixLen .. $];\n-    const char quote = rest[0];\n-\n-    const bool triple = rest.length >= 6 && rest[1] == quote && rest[2] == quote;\n-    auto content = triple ? rest[3 .. $ - 3] : rest[1 .. $ - 1];\n-\n-    if (isRaw)\n-        return content;\n-\n-    return processEscapes(content);\n-}\n-\n-private string processEscapes(string s)\n-{\n-    char[] result;\n-    size_t i = 0;\n-    while (i < s.length)\n-    {\n-        if (s[i] == '\\\\' && i + 1 < s.length)\n-        {\n-            switch (s[i + 1])\n-            {\n-            case 'n':\n-                result ~= '\\n';\n-                break;\n-            case 'r':\n-                result ~= '\\r';\n-                break;\n-            case 't':\n-                result ~= '\\t';\n-                break;\n-            case '\\\\':\n-                result ~= '\\\\';\n-                break;\n-            case '\\'':\n-                result ~= '\\'';\n-                break;\n-            case '\"':\n-                result ~= '\"';\n-                break;\n-            case '0':\n-                result ~= '\\0';\n-                break;\n-            case 'a':\n-                result ~= '\\a';\n-                break;\n-            case 'b':\n-                result ~= '\\b';\n-                break;\n-            case 'f':\n-                result ~= '\\f';\n-                break;\n-            case 'v':\n-                result ~= '\\v';\n-                break;\n-            default:\n-                result ~= s[i .. i + 2];\n-                break;\n-            }\n-            i += 2;\n-        }\n-        else\n-        {\n-            result ~= s[i];\n-            i++;\n-        }\n-    }\n-    return cast(string) result;\n-}\n-\n-// \u2500\u2500 Duration / Timestamp helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-/// Parse an ISO 8601 duration string (e.g., \"PT1H30M\", \"PT30S\", \"P1DT12H\").\n-/// Returns null on parse failure.\n-private Nullable!Duration parseISO8601Duration(string s)\n-{\n-    if (s.length < 2 || s[0] != 'P')\n-        return Nullable!Duration.init;\n-\n-    size_t i = 1;\n-    long totalHnsecs = 0;\n-    bool inTime = false;\n-\n-    while (i < s.length)\n-    {\n-        if (s[i] == 'T')\n-        {\n-            inTime = true;\n-            i++;\n-            continue;\n-        }\n-\n-        // Parse number (may be fractional)\n-        size_t numStart = i;\n-        bool hasDot = false;\n-        while (i < s.length && ((s[i] >= '0' && s[i] <= '9') || s[i] == '.'))\n-        {\n-            if (s[i] == '.')\n-                hasDot = true;\n-            i++;\n-        }\n-        if (i >= s.length || i == numStart)\n-            return Nullable!Duration.init;\n-\n-        char designator = s[i];\n-        i++;\n-\n-        if (hasDot)\n-        {\n-            // Fractional \u2014 only makes sense for the last component (usually S)\n-            double val;\n-            try\n-                val = s[numStart .. i - 1].to!double;\n-            catch (ConvException)\n-                return Nullable!Duration.init;\n-\n-            if (inTime && designator == 'S')\n-                totalHnsecs += cast(long)(val * 10_000_000);\n-            else if (inTime && designator == 'M')\n-                totalHnsecs += cast(long)(val * 60 * 10_000_000);\n-            else if (inTime && designator == 'H')\n-                totalHnsecs += cast(long)(val * 3600 * 10_000_000);\n-            else\n-                return Nullable!Duration.init;\n-        }\n-        else\n-        {\n-            long val;\n-            try\n-                val = s[numStart .. i - 1].to!long;\n-            catch (ConvException)\n-                return Nullable!Duration.init;\n-\n-            if (!inTime && designator == 'D')\n-                totalHnsecs += val * 86_400 * 10_000_000;\n-            else if (inTime && designator == 'H')\n-                totalHnsecs += val * 3_600 * 10_000_000;\n-            else if (inTime && designator == 'M')\n-                totalHnsecs += val * 60 * 10_000_000;\n-            else if (inTime && designator == 'S')\n-                totalHnsecs += val * 10_000_000;\n-            else\n-                return Nullable!Duration.init;\n-        }\n-    }\n-\n-    return nullable(dur!\"hnsecs\"(totalHnsecs));\n-}\n-\n-/// Parse an RFC 3339 timestamp string (e.g., \"2023-01-15T12:30:00Z\").\n-/// Returns null on parse failure.\n-private Nullable!SysTime parseRFC3339(string s)\n-{\n-    import std.datetime.date : DateTime;\n-\n-    try\n-    {\n-        // Minimal RFC 3339: YYYY-MM-DDThh:mm:ssZ or with offset\n-        if (s.length < 20)\n-            return Nullable!SysTime.init;\n-\n-        int year = s[0 .. 4].to!int;\n-        if (s[4] != '-')\n-            return Nullable!SysTime.init;\n-        int month = s[5 .. 7].to!int;\n-        if (s[7] != '-')\n-            return Nullable!SysTime.init;\n-        int day = s[8 .. 10].to!int;\n-        if (s[10] != 'T' && s[10] != 't')\n-            return Nullable!SysTime.init;\n-        int hour = s[11 .. 13].to!int;\n-        if (s[13] != ':')\n-            return Nullable!SysTime.init;\n-        int minute = s[14 .. 16].to!int;\n-        if (s[16] != ':')\n-            return Nullable!SysTime.init;\n-        int second = s[17 .. 19].to!int;\n-\n-        // Parse optional fractional seconds\n-        long fracHnsecs = 0;\n-        size_t i = 19;\n-        if (i < s.length && s[i] == '.')\n-        {\n-            i++;\n-            size_t fracStart = i;\n-            while (i < s.length && s[i] >= '0' && s[i] <= '9')\n-                i++;\n-            string fracStr = s[fracStart .. i];\n-            // Pad or truncate to 7 digits (hnsecs)\n-            while (fracStr.length < 7)\n-                fracStr ~= '0';\n-            if (fracStr.length > 7)\n-                fracStr = fracStr[0 .. 7];\n-            fracHnsecs = fracStr.to!long;\n-        }\n-\n-        // Parse timezone: Z, +HH:MM, or -HH:MM\n-        import std.datetime.timezone : SimpleTimeZone;\n-\n-        if (i >= s.length)\n-            return Nullable!SysTime.init;\n-\n-        Duration tzOffset;\n-        if (s[i] == 'Z' || s[i] == 'z')\n-        {\n-            tzOffset = Duration.zero;\n-        }\n-        else if (s[i] == '+' || s[i] == '-')\n-        {\n-            if (i + 5 > s.length)\n-                return Nullable!SysTime.init;\n-            int tzHour = s[i + 1 .. i + 3].to!int;\n-            int tzMin = s[i + 4 .. i + 6].to!int;\n-            tzOffset = dur!\"hours\"(tzHour) + dur!\"minutes\"(tzMin);\n-            if (s[i] == '-')\n-                tzOffset = -tzOffset;\n-        }\n-        else\n-        {\n-            return Nullable!SysTime.init;\n-        }\n-\n-        auto tz = cast(immutable) new SimpleTimeZone(tzOffset);\n-\n-        import std.datetime.date : Month;\n-\n-        auto dt = DateTime(year, cast(Month) month, day, hour, minute, second);\n-        auto st = SysTime(dt, dur!\"hnsecs\"(fracHnsecs), tz);\n-        return nullable(st);\n-    }\n-    catch (Exception)\n-    {\n-        return Nullable!SysTime.init;\n-    }\n-}\n-\n-/// Format a Duration as an ISO 8601 duration string (e.g., \"PT1H30M15S\").\n-private string formatISO8601Duration(Duration d)\n-{\n-    import std.format : format;\n-\n-    long totalSecs = d.total!\"seconds\";\n-    bool negative = totalSecs < 0;\n-    if (negative)\n-        totalSecs = -totalSecs;\n-    long rem = totalSecs;\n-    long h = rem / 3600;\n-    rem %= 3600;\n-    long m = rem / 60;\n-    long s = rem % 60;\n-\n-    string result = negative ? \"-PT\" : \"PT\";\n-    if (h > 0)\n-        result ~= format!\"%dH\"(h);\n-    if (m > 0)\n-        result ~= format!\"%dM\"(m);\n-    // Always show seconds if nothing else, or if non-zero\n-    if (s > 0 || (h == 0 && m == 0))\n-        result ~= format!\"%dS\"(s);\n-    return result;\n-}\n-\n-/// Format a SysTime as an RFC 3339 timestamp string.\n-private string formatRFC3339(SysTime st)\n-{\n-    import std.format : format;\n-\n-    auto utc = st.toUTC();\n-    return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(utc.year,\n-            cast(int) utc.month, utc.day, utc.hour, utc.minute, utc.second);\n-}\n-\n-// \u2500\u2500 Value helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-/// Unwrap an Entry to its scalar value via asValue(), if available.\n-/// Returns the original value unchanged if not an Entry or no asValue().\n-private Value unwrapEntry(Value v)\n-{\n-    auto e = tryGet!Entry(v);\n-    if (!e.isNull)\n-    {\n-        auto av = e.get.asValue();\n-        if (!av.isNull)\n-            return av.get;\n-    }\n-    return v;\n-}\n-\n-private Nullable!T tryGet(T)(Value v)\n-{\n-    return v.inner.match!((ref T val) => nullable(val), (ref _) => Nullable!T.init,);\n-}\n-\n-private Nullable!double toDouble(Value v)\n-{\n-    return v.inner.match!((ref double d) => nullable(d),\n-            (ref long i) => nullable(cast(double) i),\n-            (ref ulong u) => nullable(cast(double) u), (ref _) => Nullable!(double).init,);\n-}\n-\n-/// True only for `Value(true)`. Non-bool values are NOT truthy.\n-private bool isTruthy(Value v)\n-{\n-    return v.inner.match!((ref bool b) => b, (ref _) => false,);\n-}\n-\n-/// True only for `Value(false)`. Non-bool values are NOT falsy.\n-private bool isFalsy(Value v)\n-{\n-    return v.inner.match!((ref bool b) => !b, (ref _) => false,);\n-}\n-\n-/// Coerce a value to bool, returning an error for non-bool types.\n-private Value toBool(Value v)\n-{\n-    if (v.type == Value.Type.bool_ || v.type == Value.Type.err)\n-        return v;\n-    return Value.err(\"expected bool, got \" ~ typeName(v));\n-}\n-\n-private string typeName(Value v)\n-{\n-    final switch (v.type)\n-    {\n-    case Value.Type.null_:\n-        return \"null\";\n-    case Value.Type.bool_:\n-        return \"bool\";\n-    case Value.Type.int_:\n-        return \"int\";\n-    case Value.Type.uint_:\n-        return \"uint\";\n-    case Value.Type.double_:\n-        return \"double\";\n-    case Value.Type.string_:\n-        return \"string\";\n-    case Value.Type.bytes_:\n-        return \"bytes\";\n-    case Value.Type.list:\n-        return \"list\";\n-    case Value.Type.map:\n-        return \"map\";\n-    case Value.Type.entry:\n-        return \"entry\";\n-    case Value.Type.duration:\n-        return \"google.protobuf.Duration\";\n-    case Value.Type.timestamp:\n-        return \"google.protobuf.Timestamp\";\n-    case Value.Type.err:\n-        return \"error\";\n-    }\n-}\n-\n-// \u2500\u2500 Tests \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-\n-@(\"Eval: integer arithmetic\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 + 2\", emptyContext()).should.be(value(3L));\n-    evaluate(\"10 - 3\", emptyContext()).should.be(value(7L));\n-    evaluate(\"4 * 5\", emptyContext()).should.be(value(20L));\n-    evaluate(\"15 / 4\", emptyContext()).should.be(value(3L));\n-    evaluate(\"15 % 4\", emptyContext()).should.be(value(3L));\n-}\n-\n-@(\"Eval: operator precedence\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"2 + 3 * 4\", emptyContext()).should.be(value(14L));\n-    evaluate(\"(2 + 3) * 4\", emptyContext()).should.be(value(20L));\n-}\n-\n-@(\"Eval: comparison operators\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 < 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"2 <= 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"3 > 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"2 >= 3\", emptyContext()).should.be(value(false));\n-    evaluate(\"1 == 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 != 2\", emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: logical operators\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"true && true\", emptyContext()).should.be(value(true));\n-    evaluate(\"true && false\", emptyContext()).should.be(value(false));\n-    evaluate(\"false || true\", emptyContext()).should.be(value(true));\n-    evaluate(\"false || false\", emptyContext()).should.be(value(false));\n-    evaluate(\"!true\", emptyContext()).should.be(value(false));\n-    evaluate(\"!false\", emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: logical operators reject non-bool operands\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 && true\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(`\"yes\" && true`, emptyContext()).type.should.be(Value.Type.err);\n-    // Short-circuit still absorbs: false && <non-bool> \u2192 false, true || <non-bool> \u2192 true\n-    evaluate(\"false && 1\", emptyContext()).should.be(value(false));\n-    evaluate(\"true || 1\", emptyContext()).should.be(value(true));\n-    // Non-short-circuit path rejects non-bool RHS\n-    evaluate(\"true && 1\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(\"false || 1\", emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: string operations\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`\"hello\" + \" \" + \"world\"`, emptyContext()).should.be(value(\"hello world\"));\n-    evaluate(`\"abc\" == \"abc\"`, emptyContext()).should.be(value(true));\n-    evaluate(`\"abc\" != \"def\"`, emptyContext()).should.be(value(true));\n-    evaluate(`\"abc\" < \"def\"`, emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: string methods\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`\"hello world\".contains(\"world\")`, emptyContext()).should.be(value(true));\n-    evaluate(`\"hello world\".startsWith(\"hello\")`, emptyContext()).should.be(value(true));\n-    evaluate(`\"hello world\".endsWith(\"world\")`, emptyContext()).should.be(value(true));\n-    evaluate(`\"hello\".size()`, emptyContext()).should.be(value(5L));\n-}\n-\n-@(\"Eval: context variable lookup\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto ctx = contextFrom([\"x\": value(10L), \"name\": value(\"alice\")]);\n-    evaluate(\"x\", ctx).should.be(value(10L));\n-    evaluate(\"name\", ctx).should.be(value(\"alice\"));\n-    evaluate(\"x + 5\", ctx).should.be(value(15L));\n-}\n-\n-@(\"Eval: ternary conditional\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"true ? 1 : 2\", emptyContext()).should.be(value(1L));\n-    evaluate(\"false ? 1 : 2\", emptyContext()).should.be(value(2L));\n-}\n-\n-@(\"Eval: ternary rejects non-bool condition\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 ? 2 : 3\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(`\"yes\" ? 1 : 0`, emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: list literals and indexing\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3][0]\", emptyContext()).should.be(value(1L));\n-    evaluate(\"[1, 2, 3][2]\", emptyContext()).should.be(value(3L));\n-    evaluate(\"size([1, 2, 3])\", emptyContext()).should.be(value(3L));\n-}\n-\n-@(\"Eval: map literals and access\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`{\"a\": 1, \"b\": 2}.a`, emptyContext()).should.be(value(1L));\n-    evaluate(`{\"a\": 1, \"b\": 2}[\"b\"]`, emptyContext()).should.be(value(2L));\n-}\n-\n-@(\"Eval: unary minus\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"-5\", emptyContext()).should.be(value(-5L));\n-    evaluate(\"-3.14\", emptyContext()).should.be(value(-3.14));\n-    evaluate(\"-(2 + 3)\", emptyContext()).should.be(value(-5L));\n-}\n-\n-@(\"Eval: float arithmetic\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1.5 + 2.5\", emptyContext()).should.be(value(4.0));\n-    evaluate(\"3.0 * 2.0\", emptyContext()).should.be(value(6.0));\n-}\n-\n-@(\"Eval: type casts\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`int(\"42\")`, emptyContext()).should.be(value(42L));\n-    evaluate(\"double(42)\", emptyContext()).should.be(value(42.0));\n-    evaluate(`string(42)`, emptyContext()).should.be(value(\"42\"));\n-}\n-\n-@(\"Eval: in operator\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`\"el\" in \"hello\"`, emptyContext()).should.be(value(true));\n-    evaluate(`\"x\" in {\"x\": 1, \"y\": 2}`, emptyContext()).should.be(value(true));\n-    evaluate(`\"z\" in {\"x\": 1, \"y\": 2}`, emptyContext()).should.be(value(false));\n-}\n-\n-@(\"Eval: division by zero returns error value\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 / 0\", emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: syntax error throws\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1 +\", emptyContext()).should.throwA!EvalException;\n-    evaluate(\"\", emptyContext()).should.throwA!EvalException;\n-}\n-\n-@(\"Eval: unknown variable from context\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto result = evaluate(\"x\", emptyContext());\n-    result.type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: nested member access\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto ctx = contextFrom([\n-        \"req\": value([\"method\": value(\"GET\"), \"host\": value(\"example.com\")])\n-    ]);\n-    evaluate(`req.method`, ctx).should.be(value(\"GET\"));\n-    evaluate(`req.host == \"example.com\"`, ctx).should.be(value(true));\n-}\n-\n-@(\"Eval: short-circuit evaluation\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"false && (1/0 == 1)\", emptyContext()).should.be(value(false));\n-    evaluate(\"true || (1/0 == 1)\", emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: has() macro\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto ctx = contextFrom([\n-        \"req\": value([\"method\": value(\"GET\"), \"path\": value(\"/api\")])\n-    ]);\n-    evaluate(`has(req.method)`, ctx).should.be(value(true));\n-    evaluate(`has(req.missing)`, ctx).should.be(value(false));\n-    evaluate(`has(req)`, ctx).should.be(value(true));\n-    evaluate(`has(unknown)`, ctx).should.be(value(false));\n-}\n-\n-@(\"Eval: in operator with list membership\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`1 in [1, 2, 3]`, emptyContext()).should.be(value(true));\n-    evaluate(`4 in [1, 2, 3]`, emptyContext()).should.be(value(false));\n-    evaluate(`\"a\" in [\"a\", \"b\", \"c\"]`, emptyContext()).should.be(value(true));\n-    evaluate(`\"d\" in [\"a\", \"b\", \"c\"]`, emptyContext()).should.be(value(false));\n-}\n-\n-@(\"Eval: custom macros\")\n-unittest\n-{\n-    import dshould;\n-\n-    Macro[string] customs;\n-    customs[\"always\"] = delegate Value(ref TokenRange r, const Env env, Context ctx) {\n-        parseExpr(r, env, ctx, 0); // evaluate and discard\n-        r.expect(Token.Kind.rparen);\n-        return Value(true);\n-    };\n-    evaluateWithMacros(`always(1 + 2)`, emptyContext(), customs).should.be(value(true));\n-}\n-\n-@(\"Eval: list.all() comprehension\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3].all(x, x > 0)\", emptyContext()).should.be(value(true));\n-    evaluate(\"[1, 2, 3].all(x, x > 2)\", emptyContext()).should.be(value(false));\n-    evaluate(\"[].all(x, x > 0)\", emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: list.exists() comprehension\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3].exists(x, x == 2)\", emptyContext()).should.be(value(true));\n-    evaluate(\"[1, 2, 3].exists(x, x > 5)\", emptyContext()).should.be(value(false));\n-    evaluate(\"[].exists(x, x > 0)\", emptyContext()).should.be(value(false));\n-}\n-\n-@(\"Eval: list.exists_one() comprehension\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3].exists_one(x, x == 2)\", emptyContext()).should.be(value(true));\n-    evaluate(\"[1, 2, 3].exists_one(x, x > 1)\", emptyContext()).should.be(value(false));\n-    evaluate(\"[1, 2, 3].exists_one(x, x > 5)\", emptyContext()).should.be(value(false));\n-}\n-\n-@(\"Eval: list.map() comprehension\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3].map(x, x * 2)\", emptyContext()).should.be(value([\n-        value(2L), value(4L), value(6L)\n-    ]));\n-    evaluate(\"[].map(x, x + 1)\", emptyContext()).should.be(value(cast(Value[])[]));\n-}\n-\n-@(\"Eval: list.filter() comprehension\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3, 4, 5].filter(x, x > 3)\", emptyContext()).should.be(\n-            value([value(4L), value(5L)]));\n-    evaluate(\"[1, 2, 3].filter(x, x > 5)\", emptyContext()).should.be(value(cast(Value[])[\n-    ]));\n-}\n-\n-@(\"Eval: comprehension with context variables\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto ctx = contextFrom([\"threshold\": value(2L)]);\n-    evaluate(\"[1, 2, 3, 4].filter(x, x > threshold)\", ctx).should.be(value([\n-        value(3L), value(4L)\n-    ]));\n-    evaluate(\"[1, 2, 3].all(x, x > threshold)\", ctx).should.be(value(false));\n-    evaluate(\"[3, 4, 5].all(x, x > threshold)\", ctx).should.be(value(true));\n-}\n-\n-@(\"Eval: chained comprehensions\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"[1, 2, 3, 4].map(x, x * 2).filter(y, y > 4)\", emptyContext()).should.be(\n-            value([value(6L), value(8L)]));\n-}\n-\n-@(\"Eval: error propagation\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(\"1/0 + 1\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(\"-(1/0)\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(\"true || (1/0 == 1)\", emptyContext()).should.be(value(true));\n-    evaluate(\"false && (1/0 == 1)\", emptyContext()).should.be(value(false));\n-    evaluate(\"true && (1/0 == 1)\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(\"false || (1/0 == 1)\", emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: .matches() regex method\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Basic matching\n-    evaluate(`\"hello\".matches(\"hel.*\")`, emptyContext()).should.be(value(true));\n-    evaluate(`\"hello\".matches(\"world\")`, emptyContext()).should.be(value(false));\n-\n-    // Full string match (not partial)\n-    evaluate(`\"hello world\".matches(\"hello\")`, emptyContext()).should.be(value(false));\n-    evaluate(`\"hello world\".matches(\"hello.*\")`, emptyContext()).should.be(value(true));\n-\n-    // Character classes\n-    evaluate(`\"abc123\".matches(\"[a-z]+[0-9]+\")`, emptyContext()).should.be(value(true));\n-\n-    // Empty string\n-    evaluate(`\"\".matches(\"\")`, emptyContext()).should.be(value(true));\n-    evaluate(`\"\".matches(\".\")`, emptyContext()).should.be(value(false));\n-}\n-\n-@(\"Eval: null semantics\")\n-unittest\n-{\n-    import dshould;\n-\n-    // null == null \u2192 true\n-    evaluate(\"null == null\", emptyContext()).should.be(value(true));\n-    // null != non-null \u2192 true\n-    evaluate(\"null != 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 != null\", emptyContext()).should.be(value(true));\n-    evaluate(`null != \"x\"`, emptyContext()).should.be(value(true));\n-    // null == non-null \u2192 false\n-    evaluate(\"null == 1\", emptyContext()).should.be(value(false));\n-    evaluate(\"1 == null\", emptyContext()).should.be(value(false));\n-    // null arithmetic \u2192 error\n-    evaluate(\"null + 1\", emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(\"null < 1\", emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: cross-type numeric comparison\")\n-unittest\n-{\n-    import dshould;\n-\n-    // int vs uint equality\n-    evaluate(\"1u == 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 == 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"1u != 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"1u != 1\", emptyContext()).should.be(value(false));\n-\n-    // int vs uint ordering\n-    evaluate(\"1u < 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"2u > 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1u <= 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1u >= 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"3u > 2\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 < 2u\", emptyContext()).should.be(value(true));\n-    evaluate(\"2 > 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 <= 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 >= 1u\", emptyContext()).should.be(value(true));\n-\n-    // negative int vs uint\n-    evaluate(\"-1 < 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"-1 == 1u\", emptyContext()).should.be(value(false));\n-    evaluate(\"-1 != 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"-1 <= 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"-1 > 1u\", emptyContext()).should.be(value(false));\n-    evaluate(\"-1 >= 1u\", emptyContext()).should.be(value(false));\n-\n-    // cross-type arithmetic\n-    evaluate(\"1u + 1\", emptyContext()).type.should.not.be(Value.Type.err);\n-    evaluate(\"3u - 1\", emptyContext()).type.should.not.be(Value.Type.err);\n-    evaluate(\"2u * 3\", emptyContext()).type.should.not.be(Value.Type.err);\n-    evaluate(\"1 + 1u\", emptyContext()).type.should.not.be(Value.Type.err);\n-    evaluate(\"3 - 1u\", emptyContext()).type.should.not.be(Value.Type.err);\n-\n-    // double promotion from either type\n-    evaluate(\"1.0 == 1\", emptyContext()).should.be(value(true));\n-    evaluate(\"1.0 == 1u\", emptyContext()).should.be(value(true));\n-    evaluate(\"1 + 1.5\", emptyContext()).should.be(value(2.5));\n-    evaluate(\"1u + 1.5\", emptyContext()).should.be(value(2.5));\n-}\n-\n-@(\"Eval: duration constructor and methods\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Parse ISO 8601 durations\n-    evaluate(`duration(\"PT30S\")`, emptyContext()).type.should.be(Value.Type.duration);\n-    evaluate(`duration(\"PT1H30M\")`, emptyContext()).type.should.be(Value.Type.duration);\n-    evaluate(`duration(\"PT1H\")`, emptyContext()).type.should.be(Value.Type.duration);\n-    evaluate(`duration(\"P1DT12H\")`, emptyContext()).type.should.be(Value.Type.duration);\n-\n-    // Accessor methods\n-    evaluate(`duration(\"PT1H30M\").hours()`, emptyContext()).should.be(value(1L));\n-    evaluate(`duration(\"PT1H30M\").minutes()`, emptyContext()).should.be(value(90L));\n-    evaluate(`duration(\"PT1H30M\").seconds()`, emptyContext()).should.be(value(5400L));\n-    evaluate(`duration(\"PT90S\").minutes()`, emptyContext()).should.be(value(1L));\n-    evaluate(`duration(\"PT90S\").seconds()`, emptyContext()).should.be(value(90L));\n-\n-    // Invalid duration \u2192 error\n-    evaluate(`duration(\"not a duration\")`, emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(`duration(42)`, emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: duration arithmetic\")\n-unittest\n-{\n-    import dshould;\n-\n-    // duration + duration\n-    evaluate(`duration(\"PT1H\") + duration(\"PT30M\")`, emptyContext()).should.be(\n-            evaluate(`duration(\"PT1H30M\")`, emptyContext()));\n-\n-    // duration - duration\n-    evaluate(`duration(\"PT1H\") - duration(\"PT30M\")`, emptyContext()).should.be(\n-            evaluate(`duration(\"PT30M\")`, emptyContext()));\n-\n-    // duration comparison\n-    evaluate(`duration(\"PT1H\") > duration(\"PT30M\")`, emptyContext()).should.be(value(true));\n-    evaluate(`duration(\"PT1H\") < duration(\"PT30M\")`, emptyContext()).should.be(value(false));\n-    evaluate(`duration(\"PT1H\") == duration(\"PT1H\")`, emptyContext()).should.be(value(true));\n-    evaluate(`duration(\"PT1H\") != duration(\"PT30M\")`, emptyContext()).should.be(value(true));\n-    evaluate(`duration(\"PT1H\") >= duration(\"PT1H\")`, emptyContext()).should.be(value(true));\n-    evaluate(`duration(\"PT30M\") <= duration(\"PT1H\")`, emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: timestamp constructor and methods\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Parse RFC 3339 timestamps\n-    evaluate(`timestamp(\"2023-01-15T12:30:00Z\")`, emptyContext()).type.should.be(\n-            Value.Type.timestamp);\n-\n-    // Accessor methods\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").year()`, emptyContext()).should.be(value(2023L));\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").month()`, emptyContext()).should.be(value(1L));\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").day()`, emptyContext()).should.be(value(15L));\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").hour()`, emptyContext()).should.be(value(12L));\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").minute()`, emptyContext()).should.be(value(30L));\n-    evaluate(`timestamp(\"2023-01-15T12:30:45Z\").second()`, emptyContext()).should.be(value(45L));\n-\n-    // Invalid timestamp \u2192 error\n-    evaluate(`timestamp(\"not a timestamp\")`, emptyContext()).type.should.be(Value.Type.err);\n-    evaluate(`timestamp(42)`, emptyContext()).type.should.be(Value.Type.err);\n-}\n-\n-@(\"Eval: timestamp arithmetic\")\n-unittest\n-{\n-    import dshould;\n-\n-    // timestamp + duration\n-    evaluate(`timestamp(\"2023-01-15T12:00:00Z\") + duration(\"PT1H\")`, emptyContext()).should.be(\n-            evaluate(`timestamp(\"2023-01-15T13:00:00Z\")`, emptyContext()));\n-\n-    // timestamp - duration\n-    evaluate(`timestamp(\"2023-01-15T12:00:00Z\") - duration(\"PT1H\")`, emptyContext()).should.be(\n-            evaluate(`timestamp(\"2023-01-15T11:00:00Z\")`, emptyContext()));\n-\n-    // duration + timestamp (commutative)\n-    evaluate(`duration(\"PT1H\") + timestamp(\"2023-01-15T12:00:00Z\")`, emptyContext()).should.be(\n-            evaluate(`timestamp(\"2023-01-15T13:00:00Z\")`, emptyContext()));\n-\n-    // timestamp comparison\n-    evaluate(`timestamp(\"2023-01-15T12:00:00Z\") < timestamp(\"2023-01-15T13:00:00Z\")`,\n-            emptyContext()).should.be(value(true));\n-    evaluate(`timestamp(\"2023-01-15T12:00:00Z\") == timestamp(\"2023-01-15T12:00:00Z\")`,\n-            emptyContext()).should.be(value(true));\n-    evaluate(`timestamp(\"2023-01-15T13:00:00Z\") > timestamp(\"2023-01-15T12:00:00Z\")`,\n-            emptyContext()).should.be(value(true));\n-}\n-\n-@(\"Eval: timestamp - timestamp \u2192 duration\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto result = evaluate(`timestamp(\"2023-01-15T13:00:00Z\") - timestamp(\"2023-01-15T12:00:00Z\")`,\n-            emptyContext());\n-    result.type.should.be(Value.Type.duration);\n-    // The resulting duration should be 1 hour\n-    evaluate(`(timestamp(\"2023-01-15T13:00:00Z\") - timestamp(\"2023-01-15T12:00:00Z\")).seconds()`,\n-            emptyContext()).should.be(value(3600L));\n-}\n-\n-@(\"Eval: duration and timestamp string() cast\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`string(duration(\"PT1H30M\"))`, emptyContext()).should.be(value(\"PT1H30M\"));\n-    evaluate(`string(duration(\"PT30S\"))`, emptyContext()).should.be(value(\"PT30S\"));\n-    evaluate(`string(timestamp(\"2023-01-15T12:30:00Z\"))`, emptyContext()).should.be(\n-            value(\"2023-01-15T12:30:00Z\"));\n-}\n-\n-@(\"Eval: type() for duration and timestamp\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`type(duration(\"PT1H\"))`, emptyContext()).should.be(value(\"google.protobuf.Duration\"));\n-    evaluate(`type(timestamp(\"2023-01-15T12:00:00Z\"))`, emptyContext()).should.be(\n-            value(\"google.protobuf.Timestamp\"));\n-}\n-\n-@(\"Eval: lazy List subclass\")\n-unittest\n-{\n-    import dshould;\n-\n-    // Create a lazy list backed by List subclass\n-    class RangeList : List\n-    {\n-        long start;\n-        long count;\n-        this(long s, long c)\n-        {\n-            start = s;\n-            count = c;\n-        }\n-\n-        override size_t length()\n-        {\n-            return cast(size_t) count;\n-        }\n-\n-        override Value index(size_t i)\n-        {\n-            return value(start + cast(long) i);\n-        }\n-    }\n-\n-    auto ctx = contextFrom([\"nums\": Value(cast(List) new RangeList(10, 5))]);\n-\n-    // size()\n-    evaluate(\"size(nums)\", ctx).should.be(value(5L));\n-    evaluate(\"nums.size()\", ctx).should.be(value(5L));\n-\n-    // indexing\n-    evaluate(\"nums[0]\", ctx).should.be(value(10L));\n-    evaluate(\"nums[4]\", ctx).should.be(value(14L));\n-    evaluate(\"nums[2]\", ctx).should.be(value(12L));\n-\n-    // negative indexing\n-    evaluate(\"nums[-1]\", ctx).should.be(value(14L));\n-\n-    // out of range\n-    evaluate(\"nums[5]\", ctx).type.should.be(Value.Type.err);\n-\n-    // in operator\n-    evaluate(\"10 in nums\", ctx).should.be(value(true));\n-    evaluate(\"14 in nums\", ctx).should.be(value(true));\n-    evaluate(\"15 in nums\", ctx).should.be(value(false));\n-\n-    // type()\n-    evaluate(\"type(nums)\", ctx).should.be(value(\"list\"));\n-\n-    // comprehensions\n-    evaluate(\"nums.all(x, x >= 10)\", ctx).should.be(value(true));\n-    evaluate(\"nums.all(x, x > 10)\", ctx).should.be(value(false));\n-    evaluate(\"nums.exists(x, x == 12)\", ctx).should.be(value(true));\n-    evaluate(\"nums.exists(x, x == 99)\", ctx).should.be(value(false));\n-    evaluate(\"nums.exists_one(x, x == 12)\", ctx).should.be(value(true));\n-    evaluate(\"nums.map(x, x * 2)\", ctx).should.be(value([\n-        value(20L), value(22L), value(24L), value(26L), value(28L)\n-    ]));\n-    evaluate(\"nums.filter(x, x > 12)\", ctx).should.be(value([\n-        value(13L), value(14L)\n-    ]));\n-}\n-\n-@(\"Eval: now() function\")\n-unittest\n-{\n-    import dshould;\n-    import std.datetime.systime : Clock;\n-\n-    auto result = evaluate(`now()`, emptyContext());\n-    result.type.should.be(Value.Type.timestamp);\n-\n-    // now() should return a timestamp close to the current time\n-    auto nowTs = Clock.currTime(UTC());\n-    auto diff = nowTs - result.get!SysTime;\n-    // Should be within 1 second\n-    assert(diff.total!\"seconds\" < 1, \"now() timestamp too far from current time\");\n-}\n-\n-@(\"Eval: now() with arithmetic\")\n-unittest\n-{\n-    import dshould;\n-\n-    // now() + duration should produce a timestamp\n-    evaluate(`now() + duration(\"PT1H\")`, emptyContext()).type.should.be(Value.Type.timestamp);\n-\n-    // now() comparison with itself (via context)\n-    evaluate(`now() >= now()`, emptyContext()).type.should.be(Value.Type.bool_);\n-}\n-\n-@(\"Eval: now() rejects arguments\")\n-unittest\n-{\n-    import dshould;\n-\n-    evaluate(`now(1)`, emptyContext()).should.throwA!EvalException;\n-}\n-\n-@(\"Eval: Entry.asList() \u2014 entry that acts as a list\")\n-unittest\n-{\n-    import dshould;\n-\n-    // An Entry that is also a List (via asList())\n-    class MetricEntry : Entry\n-    {\n-        Value[] data;\n-\n-        this(Value[] d)\n-        {\n-            data = d;\n-        }\n-\n-        override Value resolve(string name)\n-        {\n-            if (name == \"name\")\n-                return value(\"cpu_usage\");\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override List asList()\n-        {\n-            return new ArrayList(data);\n-        }\n-    }\n-\n-    auto entry = new MetricEntry([value(10L), value(20L), value(30L)]);\n-    auto ctx = contextFrom([\"metric\": Value(cast(Entry) entry)]);\n-\n-    // Can access fields as an Entry\n-    evaluate(`metric.name`, ctx).should.be(value(\"cpu_usage\"));\n-    evaluate(`has(metric.name)`, ctx).should.be(value(true));\n-    evaluate(`has(metric.missing)`, ctx).should.be(value(false));\n-\n-    // Can use as a list via asList()\n-    evaluate(`size(metric)`, ctx).should.be(value(3L));\n-    evaluate(`metric[0]`, ctx).should.be(value(10L));\n-    evaluate(`metric[2]`, ctx).should.be(value(30L));\n-    evaluate(`metric[-1]`, ctx).should.be(value(30L));\n-    evaluate(`20 in metric`, ctx).should.be(value(true));\n-    evaluate(`99 in metric`, ctx).should.be(value(false));\n-\n-    // Comprehensions work\n-    evaluate(`metric.all(x, x > 0)`, ctx).should.be(value(true));\n-    evaluate(`metric.all(x, x > 15)`, ctx).should.be(value(false));\n-    evaluate(`metric.exists(x, x == 20)`, ctx).should.be(value(true));\n-    evaluate(`metric.map(x, x * 2)`, ctx).should.be(value([\n-        value(20L), value(40L), value(60L)\n-    ]));\n-    evaluate(`metric.filter(x, x > 15)`, ctx).should.be(value([\n-        value(20L), value(30L)\n-    ]));\n-}\n-\n-@(\"Eval: Entry.asValue() \u2014 entry that unwraps to a scalar\")\n-unittest\n-{\n-    import dshould;\n-    import std.typecons : Nullable, nullable;\n-\n-    // An Entry that has a scalar value and named fields\n-    class GaugeEntry : Entry\n-    {\n-        double currentValue;\n-        string label;\n-\n-        this(double v, string l)\n-        {\n-            currentValue = v;\n-            label = l;\n-        }\n-\n-        override Value resolve(string name)\n-        {\n-            if (name == \"label\")\n-                return value(label);\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override Nullable!Value asValue()\n-        {\n-            return nullable(value(currentValue));\n-        }\n-    }\n-\n-    auto gauge = new GaugeEntry(42.5, \"cpu\");\n-    auto ctx = contextFrom([\"gauge\": Value(cast(Entry) gauge)]);\n-\n-    // Can access fields\n-    evaluate(`gauge.label`, ctx).should.be(value(\"cpu\"));\n-\n-    // Unwraps to scalar in arithmetic/comparison\n-    evaluate(`gauge + 1.0`, ctx).should.be(value(43.5));\n-    evaluate(`gauge > 40.0`, ctx).should.be(value(true));\n-    evaluate(`gauge < 50.0`, ctx).should.be(value(true));\n-    evaluate(`gauge == 42.5`, ctx).should.be(value(true));\n-    evaluate(`-gauge`, ctx).should.be(value(-42.5));\n-}\n-\n-@(\"Eval: Entry.methodMacro() \u2014 entry-level method macros\")\n-unittest\n-{\n-    import dshould;\n-\n-    // An Entry that defines its own .where() method macro\n-    class MetricEntry : Entry\n-    {\n-        string metricName;\n-        Value[] series;\n-\n-        this(string name, Value[] data)\n-        {\n-            metricName = name;\n-            series = data;\n-        }\n-\n-        override Value resolve(string name)\n-        {\n-            if (name == \"name\")\n-                return value(metricName);\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override List asList()\n-        {\n-            return new ArrayList(series);\n-        }\n-\n-        override Nullable!Value evalMacro(string name, Value self,\n-                ref TokenRange r, const Env env, Context ctx)\n-        {\n-            if (name == \"where\")\n-            {\n-                // Parse a single threshold argument: .where(threshold)\n-                auto args = parseArgList(r, env, ctx);\n-                r.expect(Token.Kind.rparen);\n-                if (args.length != 1)\n-                    return nullable(Value.err(\".where() takes exactly 1 argument\"));\n-                auto threshold = tryGet!long(args[0]);\n-                if (threshold.isNull)\n-                    return nullable(Value.err(\".where() requires an int argument\"));\n-                // Filter series > threshold\n-                auto me = cast(MetricEntry) self.get!Entry;\n-                Value[] filtered;\n-                foreach (v; me.series)\n-                {\n-                    auto iv = tryGet!long(v);\n-                    if (!iv.isNull && iv.get > threshold.get)\n-                        filtered ~= v;\n-                }\n-                return nullable(Value(cast(Entry) new MetricEntry(me.metricName, filtered)));\n-            }\n-            return Nullable!Value.init;\n-        }\n-    }\n-\n-    auto entry = new MetricEntry(\"cpu\", [\n-        value(10L), value(50L), value(80L), value(30L)\n-    ]);\n-    auto ctx = contextFrom([\"metric\": Value(cast(Entry) entry)]);\n-\n-    // Entry-level method macro: .where(threshold) filters series\n-    evaluate(`metric.where(25).name`, ctx).should.be(value(\"cpu\"));\n-    evaluate(`size(metric.where(25))`, ctx).should.be(value(3L));\n-    evaluate(`size(metric.where(60))`, ctx).should.be(value(1L));\n-\n-    // Chaining: .where() then comprehension\n-    evaluate(`metric.where(25).all(x, x > 25)`, ctx).should.be(value(true));\n-    evaluate(`metric.where(0).exists(x, x == 10)`, ctx).should.be(value(true));\n-\n-    // Original entry still works as a list\n-    evaluate(`size(metric)`, ctx).should.be(value(4L));\n-    evaluate(`metric.all(x, x > 0)`, ctx).should.be(value(true));\n-}\n-\n-@(\"Eval: Entry.methodMacro() \u2014 non-matching falls through\")\n-unittest\n-{\n-    import dshould;\n-\n-    // An Entry that only defines .custom(), other methods fall through\n-    class CustomEntry : Entry\n-    {\n-        override Value resolve(string name)\n-        {\n-            if (name == \"val\")\n-                return value(\"hello\");\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override Nullable!Value evalMacro(string name, Value, ref TokenRange r,\n-                const Env env, Context ctx)\n-        {\n-            if (name == \"custom\")\n-            {\n-                cast(void) parseArgList(r, env, ctx);\n-                r.expect(Token.Kind.rparen);\n-                return nullable(value(\"custom called\"));\n-            }\n-            return Nullable!Value.init;\n-        }\n-    }\n-\n-    auto ctx = contextFrom([\"obj\": Value(cast(Entry) new CustomEntry())]);\n-\n-    // Entry-level macro works\n-    evaluate(`obj.custom()`, ctx).should.be(value(\"custom called\"));\n-\n-    // Field access still works\n-    evaluate(`obj.val`, ctx).should.be(value(\"hello\"));\n-}\n-\n-@(\"Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax\")\n-unittest\n-{\n-    import dshould;\n-\n-    struct TimeSeries\n-    {\n-        string[string] labels;\n-        long val;\n-    }\n-\n-    class MetricEntry : Entry\n-    {\n-        string metricName;\n-        TimeSeries[] series;\n-\n-        this(string name, TimeSeries[] data)\n-        {\n-            metricName = name;\n-            series = data;\n-        }\n-\n-        override Value resolve(string name)\n-        {\n-            if (name == \"name\")\n-                return value(metricName);\n-            if (name == \"count\")\n-                return value(cast(long) series.length);\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override List asList()\n-        {\n-            Value[] elems;\n-            foreach (ref s; series)\n-            {\n-                Value[string] m;\n-                foreach (k, v; s.labels)\n-                    m[k] = value(v);\n-                m[\"value\"] = value(s.val);\n-                elems ~= Value(m);\n-            }\n-            return new ArrayList(elems);\n-        }\n-\n-        /// Parse {key = \"val\", ...} or {key == \"val\", ...} continuation syntax.\n-        override Nullable!Value evalContinuation(Value self, ref TokenRange r,\n-                const Env env, Context ctx)\n-        {\n-            if (r.peek().kind != Token.Kind.lbrace)\n-                return Nullable!Value.init;\n-\n-            r.advance(); // consume '{'\n-\n-            // Parse key = expr or key == expr pairs\n-            string[string] filters;\n-            if (r.peek().kind != Token.Kind.rbrace)\n-            {\n-                auto keyTok = r.expect(Token.Kind.ident);\n-                // Accept both = and == for Prometheus compatibility\n-                if (!r.match(Token.Kind.eq))\n-                    r.expect(Token.Kind.eqEq);\n-                auto val = parseExpr(r, env, ctx, 0);\n-                filters[keyTok.text] = val.get!string;\n-\n-                while (r.match(Token.Kind.comma))\n-                {\n-                    keyTok = r.expect(Token.Kind.ident);\n-                    if (!r.match(Token.Kind.eq))\n-                        r.expect(Token.Kind.eqEq);\n-                    val = parseExpr(r, env, ctx, 0);\n-                    filters[keyTok.text] = val.get!string;\n-                }\n-            }\n-            r.expect(Token.Kind.rbrace);\n-\n-            // Filter series\n-            TimeSeries[] matched;\n-            foreach (ref s; series)\n-            {\n-                bool pass = true;\n-                foreach (k, v; filters)\n-                {\n-                    auto p = k in s.labels;\n-                    if (p is null || *p != v)\n-                    {\n-                        pass = false;\n-                        break;\n-                    }\n-                }\n-                if (pass)\n-                    matched ~= s;\n-            }\n-            return nullable(Value(cast(Entry) new MetricEntry(metricName, matched)));\n-        }\n-    }\n-\n-    auto metric = new MetricEntry(\"http_requests\", [\n-        TimeSeries([\"method\": \"GET\", \"status\": \"200\"], 1500),\n-        TimeSeries([\"method\": \"GET\", \"status\": \"404\"], 35),\n-        TimeSeries([\"method\": \"POST\", \"status\": \"200\"], 800),\n-        TimeSeries([\"method\": \"POST\", \"status\": \"500\"], 12),\n-    ]);\n-\n-    auto ctx = contextFrom([\"http_requests\": Value(cast(Entry) metric)]);\n-\n-    // Basic attribute filter \u2014 Prometheus single = syntax\n-    evaluate(`http_requests{method = \"GET\"}.count`, ctx).should.be(value(2L));\n-    evaluate(`http_requests{method = \"POST\"}.count`, ctx).should.be(value(2L));\n-    evaluate(`http_requests{method = \"GET\", status = \"200\"}.count`, ctx).should.be(value(1L));\n-\n-    // Double == also works\n-    evaluate(`http_requests{method == \"GET\"}.count`, ctx).should.be(value(2L));\n-\n-    // Empty filter returns all\n-    evaluate(`http_requests{}.count`, ctx).should.be(value(4L));\n-\n-    // Chained with comprehensions via asList()\n-    evaluate(`http_requests{method == \"GET\"}.all(x, x.value > 0)`, ctx).should.be(value(true));\n-    evaluate(`http_requests{method == \"GET\"}.exists(x, x.status == \"404\")`, ctx).should.be(\n-            value(true));\n-\n-    // Filter then index\n-    evaluate(`http_requests{method == \"GET\", status == \"200\"}[0].value`, ctx).should.be(\n-            value(1500L));\n-\n-    // Filter with variable\n-    auto ctx2 = contextFrom([\n-        \"metric\": Value(cast(Entry) metric),\n-        \"target\": value(\"POST\"),\n-    ]);\n-    evaluate(`metric{method == target}.count`, ctx2).should.be(value(2L));\n-\n-    // Field access still works without filter\n-    evaluate(`http_requests.name`, ctx).should.be(value(\"http_requests\"));\n-    evaluate(`size(http_requests)`, ctx).should.be(value(4L));\n-}\n-\n-@(\"Eval: Entry.evalContinuation() \u2014 non-matching falls through\")\n-unittest\n-{\n-    import dshould;\n-\n-    // An Entry that doesn't define evalContinuation \u2014 normal behavior\n-    class PlainEntry : Entry\n-    {\n-        override Value resolve(string name)\n-        {\n-            if (name == \"x\")\n-                return value(42L);\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-    }\n-\n-    auto ctx = contextFrom([\"obj\": Value(cast(Entry) new PlainEntry())]);\n-\n-    // Normal member access still works\n-    evaluate(`obj.x`, ctx).should.be(value(42L));\n-    evaluate(`obj.x + 1`, ctx).should.be(value(43L));\n-}\n-\n-@(\"Eval: Entry with both asList() and asValue()\")\n-unittest\n-{\n-    import dshould;\n-    import std.typecons : Nullable, nullable;\n-\n-    // An Entry that has fields, acts as a list, AND has a scalar value\n-    class RichEntry : Entry\n-    {\n-        override Value resolve(string name)\n-        {\n-            if (name == \"description\")\n-                return value(\"test metric\");\n-            return Value.err(\"no such field: \" ~ name);\n-        }\n-\n-        override List asList()\n-        {\n-            return new ArrayList([value(1L), value(2L), value(3L)]);\n-        }\n-\n-        override Nullable!Value asValue()\n-        {\n-            return nullable(value(6L)); // sum\n-        }\n-    }\n-\n-    auto rich = new RichEntry();\n-    auto ctx = contextFrom([\"m\": Value(cast(Entry) rich)]);\n-\n-    // Fields work\n-    evaluate(`m.description`, ctx).should.be(value(\"test metric\"));\n-\n-    // List operations work\n-    evaluate(`size(m)`, ctx).should.be(value(3L));\n-    evaluate(`m[0]`, ctx).should.be(value(1L));\n-    evaluate(`m.all(x, x > 0)`, ctx).should.be(value(true));\n-\n-    // Scalar unwrapping works in arithmetic\n-    evaluate(`m + 4`, ctx).should.be(value(10L));\n-    evaluate(`m > 5`, ctx).should.be(value(true));\n-}\n-\n-@(\"Eval: duration/timestamp from context\")\n-unittest\n-{\n-    import dshould;\n-    import core.time : hours, minutes;\n-    import std.datetime.systime : SysTime;\n-    import std.datetime.date : DateTime;\n-    import std.datetime.timezone : UTC;\n-\n-    auto ctx = contextFrom([\n-        \"timeout\": value(dur!\"seconds\"(30)),\n-        \"created\": value(SysTime(DateTime(2023, 1, 15, 12, 0, 0), UTC())),\n-    ]);\n-    evaluate(\"timeout.seconds()\", ctx).should.be(value(30L));\n-    evaluate(\"created.year()\", ctx).should.be(value(2023L));\n-    evaluate(`created + duration(\"PT1H\")`, ctx).type.should.be(Value.Type.timestamp);\n-}\ndfmt reformatted: source/decel/env.d\n--- a/source/decel/env.d\t2026-02-17 14:39:29.960304252 +0100\n+++ b/source/decel/env.d\t2026-02-17 14:39:29.998570131 +0100\n@@ -1,95 +0,0 @@\n-/++\n- + CEL Environment \u2014 global evaluation configuration.\n- +\n- + Holds macro and method-macro registrations. Constructed once, immutable\n- + during evaluation. This is the extension point for custom functions.\n- +/\n-module decel.env;\n-\n-import decel.context;\n-import decel.lexer;\n-import decel.value;\n-\n-// Re-export EvalException from its own module (avoids circular imports).\n-public import decel.exception : EvalException;\n-\n-/// A function-call macro. Invoked when the parser sees `name(...)`.\n-/// The opening '(' has already been consumed; the macro must parse its\n-/// arguments and consume the closing ')' before returning.\n-alias Macro = Value delegate(ref TokenRange r, const Env env, Context ctx);\n-\n-/// A method-call macro. Invoked when the parser sees `expr.name(...)`.\n-/// The opening '(' has already been consumed; the macro must parse its\n-/// arguments and consume the closing ')' before returning.\n-/// `target` is the already-evaluated receiver expression.\n-alias MethodMacro = Value delegate(Value target, ref TokenRange r, const Env env, Context ctx);\n-\n-/// Human-readable name for a token kind.\n-string kindName(Token.Kind kind)\n-{\n-    import std.conv : to;\n-\n-    return kind.to!string;\n-}\n-\n-/// Token cursor \u2014 the linear parser state. Just a position in a token array.\n-struct TokenRange\n-{\n-    /// The full token array (shared, never modified).\n-    Token[] tokens;\n-    /// Current position in the token array.\n-    size_t pos;\n-\n-    /// Current token.\n-    Token peek() const\n-    {\n-        return tokens[pos];\n-    }\n-\n-    /// Advance and return the consumed token.\n-    Token advance()\n-    {\n-        auto tok = tokens[pos];\n-        if (tok.kind != Token.Kind.eof)\n-            pos++;\n-        return tok;\n-    }\n-\n-    /// Consume a token of the expected kind, or throw.\n-    Token expect(Token.Kind kind)\n-    {\n-        auto tok = peek();\n-        if (tok.kind != kind)\n-        {\n-            throw new EvalException(\"expected \" ~ kindName(kind) ~ \", got \" ~ tok.toString(),\n-                    tok.pos);\n-        }\n-        return advance();\n-    }\n-\n-    /// Try to consume a token of the given kind. Returns true if consumed.\n-    bool match(Token.Kind kind)\n-    {\n-        if (peek().kind == kind)\n-        {\n-            advance();\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /// Snapshot current position for replay (e.g. comprehension bodies).\n-    TokenRange save()\n-    {\n-        return TokenRange(tokens, pos);\n-    }\n-}\n-\n-/// Evaluation environment \u2014 global configuration for the evaluator.\n-struct Env\n-{\n-    /// Registered macros (function-call style).\n-    Macro[string] macros;\n-    /// Registered method macros (method-call style).\n-    MethodMacro[string] methodMacros;\n-}\ndfmt reformatted: source/decel/context.d\n--- a/source/decel/context.d\t2026-02-17 14:39:29.960131216 +0100\n+++ b/source/decel/context.d\t2026-02-17 14:39:30.004298755 +0100\n@@ -1,48 +0,0 @@\n-/++\n- + CEL evaluation context \u2014 provides variable bindings.\n- +/\n-module decel.context;\n-\n-import decel.value;\n-\n-/// A Context resolves top-level identifiers to Values.\n-/// It is simply a callable that maps names to values.\n-alias Context = Value delegate(string name);\n-\n-/// Create a context from an associative array (useful for tests).\n-Context contextFrom(Value[string] bindings)\n-{\n-    return (string name) {\n-        if (auto p = name in bindings)\n-            return *p;\n-        return Value.err(\"undefined\");\n-    };\n-}\n-\n-/// Empty context that resolves nothing.\n-Context emptyContext()\n-{\n-    return (string) => Value.err(\"undefined\");\n-}\n-\n-/// Layer a single binding on top of an existing context.\n-Context bindContext(Context outer, string name, Value val)\n-{\n-    return (string n) {\n-        if (n == name)\n-            return val;\n-        return outer(n);\n-    };\n-}\n-\n-@(\"Context: resolve bindings\")\n-unittest\n-{\n-    import dshould;\n-\n-    auto ctx = contextFrom([\"x\": value(10L), \"name\": value(\"alice\"),]);\n-\n-    ctx(\"x\").type.should.be(Value.Type.int_);\n-    ctx(\"name\").type.should.be(Value.Type.string_);\n-    ctx(\"missing\").type.should.be(Value.Type.err);\n-}\n\n--- stderr ---\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nMissing value for argument --keep_line_breaks.\nInvalid argument\nmake: *** [Makefile:33: format] Fehler 1\n",
      "_ui_only": true
    },
    {
      "role": "assistant",
      "content": "\n\nTwo issues:\n1. `--keep_line_breaks` needs `=true` (it's a boolean flag in dfmt)\n2. The `private static:` block in the struct caused `toHash` to also become static, breaking it\n\nLet me compact the huge error output first, then fix both issues.",
      "tool_calls": [
        {
          "function": {
            "arguments": "{\"from_id\": \"1\", \"to_id\": \"8\", \"summary\": \"Added Value.toString() with helper functions and tests to source/decel/value.d. Refactored toString to use private static helper functions (fmtInt, fmtUint, fmtDouble, fmtString, fmtBytes, fmtList, fmtMap, fmtDuration, fmtTimestamp) inside the Value struct, with the match table dispatching to them. Added 3 test blocks (basics, collections, duration/timestamp). Also added --keep_line_breaks to dfmt calls in Makefile.\\n\\nTwo problems found:\\n1. dfmt's --keep_line_breaks requires `=true` syntax (not just the flag alone) - got \\\"Missing value for argument\\\" errors\\n2. The `private static:` label before the fmt helpers also made `toHash` static, which is wrong - toHash needs to be a non-static method\\n\\nFiles in context: source/decel/value.d, Makefile (plus several read-only context files)\"}",
            "name": "compact"
          },
          "id": "toolu_vrtx_012uszCyeMi1kLdEY28CB7jo",
          "type": "function"
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "toolu_vrtx_012uszCyeMi1kLdEY28CB7jo",
      "content": "{\"compact\": true, \"from_id\": \"1\", \"success\": true, \"summary\": \"Added Value.toString() with helper functions and tests to source/decel/value.d. Refactored toString to use private static helper functions (fmtInt, fmtUint, fmtDouble, fmtString, fmtBytes, fmtList, fmtMap, fmtDuration, fmtTimestamp) inside the Value struct, with the match table dispatching to them. Added 3 test blocks (basics, collections, duration/timestamp). Also added --keep_line_breaks to dfmt calls in Makefile.\\n\\nTwo problems found:\\n1. dfmt's --keep_line_breaks requires `=true` syntax (not just the flag alone) - got \\\"Missing value for argument\\\" errors\\n2. The `private static:` label before the fmt helpers also made `toHash` static, which is wrong - toHash needs to be a non-static method\\n\\nFiles in context: source/decel/value.d, Makefile (plus several read-only context files)\", \"to_id\": \"8\"}",
      "_skip_display": true
    },
    {
      "role": "assistant",
      "content": "\n\nNow let me fix both issues:\n\n1. **Makefile**: Change `--keep_line_breaks` to `--keep_line_breaks=true`\n2. **value.d**: Move `toHash` before the `private static:` label so it remains a non-static method\n\n<edit file=\"Makefile\">\n<search>\n\t\t$(DFMT) --keep_line_breaks < \"$$f\" | diff -u \"$$f\" - | sed \"s|--- $$f|--- a/$$f|;s|+++ -|+++ b/$$f|\" > /tmp/dfmt_diff 2>&1 || true; \\\n\t\tif [ -s /tmp/dfmt_diff ]; then \\\n\t\t\techo \"dfmt reformatted: $$f\"; \\\n\t\t\tcat /tmp/dfmt_diff; \\\n\t\t\t$(DFMT) --keep_line_breaks -i \"$$f\"; \\\n</search>\n<replace>\n\t\t$(DFMT) --keep_line_breaks=true < \"$$f\" | diff -u \"$$f\" - | sed \"s|--- $$f|--- a/$$f|;s|+++ -|+++ b/$$f|\" > /tmp/dfmt_diff 2>&1 || true; \\\n\t\tif [ -s /tmp/dfmt_diff ]; then \\\n\t\t\techo \"dfmt reformatted: $$f\"; \\\n\t\t\tcat /tmp/dfmt_diff; \\\n\t\t\t$(DFMT) --keep_line_breaks=true -i \"$$f\"; \\\n</replace>\n</edit>\n\nNow fix the `toHash` / `private static:` issue. Move `toHash` above the `private static:` label:\n\n<edit file=\"source/decel/value.d\">\n<search>\n    /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n    /// the match table above as a clean, scannable list.\n    private static:\n\n    string fmtInt(long i)\n</search>\n<replace>\n    /// Hash support (needed when opEquals is defined).\n    size_t toHash() const nothrow @trusted\n    {\n        try\n        {\n            auto self = cast(Value) this;\n            return hashOf(cast(int) self.type());\n        }\n        catch (Exception)\n        {\n            return 0;\n        }\n    }\n\n    /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n    /// the match table above as a clean, scannable list.\n    private static:\n\n    string fmtInt(long i)\n</replace>\n</edit>\n\nNow remove the duplicate `toHash` that's currently at the bottom of the `private static:` block:\n\n<edit file=\"source/decel/value.d\">\n<search>\n    string fmtTimestamp(SysTime st)\n    {\n        import std.format : format;\n        auto utc = st.toUTC();\n        return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n            utc.year, cast(int) utc.month, utc.day,\n            utc.hour, utc.minute, utc.second);\n    }\n\n    /// Hash support (needed when opEquals is defined).\n    size_t toHash() const nothrow @trusted\n    {\n        try\n        {\n            auto self = cast(Value) this;\n            return hashOf(cast(int) self.type());\n        }\n        catch (Exception)\n        {\n            return 0;\n        }\n    }\n}\n</search>\n<replace>\n    string fmtTimestamp(SysTime st)\n    {\n        import std.format : format;\n        auto utc = st.toUTC();\n        return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n            utc.year, cast(int) utc.month, utc.day,\n            utc.hour, utc.minute, utc.second);\n    }\n}\n</replace>\n</edit>\n\n<run_tests/>\n<commit message=\"Fix two issues: dfmt --keep_line_breaks=true syntax, move toHash before private static block\n\n1. Makefile: dfmt's --keep_line_breaks is a boolean flag requiring =true\n2. value.d: Move toHash() above the 'private static:' label so it\n   remains a non-static instance method (the label was making it static,\n   which breaks the implicit opEquals contract)\"/>\n\nDone! Fixed both issues:\n\n1. **Makefile**: `--keep_line_breaks` \u2192 `--keep_line_breaks=true` (dfmt requires the `=true` suffix for boolean flags)\n2. **value.d**: Moved `toHash()` above the `private static:` label so it's a proper non-static instance method. The fmt helper functions remain in the `private static:` block where they belong.",
      "_inline_results": [
        {
          "message": "Replaced in Makefile",
          "modified_files": [
            "Makefile"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "message": "Replaced in source/decel/value.d",
          "modified_files": [
            "source/decel/value.d"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "message": "Replaced in source/decel/value.d",
          "modified_files": [
            "source/decel/value.d"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "display_output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:40:11.587939448 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:40:11.591290712 +0100\n@@ -127,7 +127,8 @@\n             Duration, // duration\n             SysTime, // timestamp\n             Err, // err\n-            );\n+            \n+    );\n \n     /// The underlying SumType storage.\n     Inner inner;\n@@ -212,19 +213,19 @@\n     {\n         auto self = cast(Value) this;\n         return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => fmtInt(i),\n-            (ref ulong u) => fmtUint(u),\n-            (ref double d) => fmtDouble(d),\n-            (ref string s) => fmtString(s),\n-            (ref immutable(ubyte)[] b) => fmtBytes(b),\n-            (ref List l) => fmtList(l),\n-            (ref Value[string] m) => fmtMap(m),\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) => fmtDuration(d),\n-            (ref SysTime t) => fmtTimestamp(t),\n-            (ref Err e) => \"error: \" ~ e.message,\n+                (ref typeof(null) _) => \"null\",\n+                (ref bool b) => b ? \"true\" : \"false\",\n+                (ref long i) => fmtInt(i),\n+                (ref ulong u) => fmtUint(u),\n+                (ref double d) => fmtDouble(d),\n+                (ref string s) => fmtString(s),\n+                (ref immutable(ubyte)[] b) => fmtBytes(b),\n+                (ref List l) => fmtList(l),\n+                (ref Value[string] m) => fmtMap(m),\n+                (ref Entry _) => \"<entry>\",\n+                (ref Duration d) => fmtDuration(d),\n+                (ref SysTime t) => fmtTimestamp(t),\n+                (ref Err e) => \"error: \" ~ e.message,\n         );\n     }\n \n@@ -244,23 +245,26 @@\n \n     /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n     /// the match table above as a clean, scannable list.\n-    private static:\n+private static:\n \n     string fmtInt(long i)\n     {\n         import std.conv : to;\n+\n         return i.to!string;\n     }\n \n     string fmtUint(ulong u)\n     {\n         import std.conv : to;\n+\n         return u.to!string ~ \"u\";\n     }\n \n     string fmtDouble(double d)\n     {\n         import std.conv : to;\n+\n         return d.to!string;\n     }\n \n@@ -272,12 +276,24 @@\n         {\n             switch (c)\n             {\n-                case '\"':  buf ~= `\\\"`; break;\n-                case '\\\\': buf ~= `\\\\`; break;\n-                case '\\n': buf ~= `\\n`; break;\n-                case '\\r': buf ~= `\\r`; break;\n-                case '\\t': buf ~= `\\t`; break;\n-                default:   buf ~= c;    break;\n+            case '\"':\n+                buf ~= `\\\"`;\n+                break;\n+            case '\\\\':\n+                buf ~= `\\\\`;\n+                break;\n+            case '\\n':\n+                buf ~= `\\n`;\n+                break;\n+            case '\\r':\n+                buf ~= `\\r`;\n+                break;\n+            case '\\t':\n+                buf ~= `\\t`;\n+                break;\n+            default:\n+                buf ~= c;\n+                break;\n             }\n         }\n         buf ~= '\"';\n@@ -287,6 +303,7 @@\n     string fmtBytes(immutable(ubyte)[] bytes)\n     {\n         import std.format : format;\n+\n         char[] buf;\n         buf ~= \"b\\\"\";\n         foreach (b; bytes)\n@@ -301,7 +318,8 @@\n         buf ~= '[';\n         foreach (i; 0 .. list.length)\n         {\n-            if (i > 0) buf ~= \", \";\n+            if (i > 0)\n+                buf ~= \", \";\n             buf ~= list.index(i).toString();\n         }\n         buf ~= ']';\n@@ -311,6 +329,7 @@\n     string fmtMap(Value[string] map)\n     {\n         import std.algorithm : sort;\n+\n         char[] buf;\n         buf ~= '{';\n         auto keys = map.keys;\n@@ -318,7 +337,8 @@\n         bool first = true;\n         foreach (k; keys)\n         {\n-            if (!first) buf ~= \", \";\n+            if (!first)\n+                buf ~= \", \";\n             first = false;\n             buf ~= fmtString(k);\n             buf ~= \": \";\n@@ -331,30 +351,37 @@\n     string fmtDuration(Duration d)\n     {\n         import std.format : format;\n+\n         long totalSecs = d.total!\"seconds\";\n         bool negative = totalSecs < 0;\n-        if (negative) totalSecs = -totalSecs;\n+        if (negative)\n+            totalSecs = -totalSecs;\n         long rem = totalSecs;\n         long h = rem / 3600;\n         rem %= 3600;\n         long m = rem / 60;\n         long sec = rem % 60;\n         char[] buf;\n-        if (negative) buf ~= '-';\n+        if (negative)\n+            buf ~= '-';\n         buf ~= \"PT\";\n-        if (h > 0) buf ~= format!\"%dH\"(h);\n-        if (m > 0) buf ~= format!\"%dM\"(m);\n-        if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n+        if (h > 0)\n+            buf ~= format!\"%dH\"(h);\n+        if (m > 0)\n+            buf ~= format!\"%dM\"(m);\n+        if (sec > 0 || (h == 0 && m == 0))\n+            buf ~= format!\"%dS\"(sec);\n         return cast(string) buf;\n     }\n \n     string fmtTimestamp(SysTime st)\n     {\n         import std.format : format;\n+\n         auto utc = st.toUTC();\n         return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n-            utc.year, cast(int) utc.month, utc.day,\n-            utc.hour, utc.minute, utc.second);\n+                utc.year, cast(int) utc.month, utc.day,\n+                utc.hour, utc.minute, utc.second);\n     }\n }\n \ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: lazy List subclass:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: list.map() comprehension:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: numeric literals:\ndecel.value.Value: deep equality:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: string methods:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.lexer.Lexer: empty input:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: single = token:\ndecel.lexer.Lexer: string literals:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: null semantics:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.value.Value: toString duration and timestamp:\ndecel.value.Value: toString basics:\ndecel.eval.Eval: string operations:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: timestamp constructor and methods:\ndecel.value.Value: toString collections:\n\nTime taken: 2 ms, 455 \u03bcs, and 2 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "modified_files": [
            "source/decel/value.d"
          ],
          "output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:40:11.587939448 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:40:11.591290712 +0100\n@@ -127,7 +127,8 @@\n             Duration, // duration\n             SysTime, // timestamp\n             Err, // err\n-            );\n+            \n+    );\n \n     /// The underlying SumType storage.\n     Inner inner;\n@@ -212,19 +213,19 @@\n     {\n         auto self = cast(Value) this;\n         return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => fmtInt(i),\n-            (ref ulong u) => fmtUint(u),\n-            (ref double d) => fmtDouble(d),\n-            (ref string s) => fmtString(s),\n-            (ref immutable(ubyte)[] b) => fmtBytes(b),\n-            (ref List l) => fmtList(l),\n-            (ref Value[string] m) => fmtMap(m),\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) => fmtDuration(d),\n-            (ref SysTime t) => fmtTimestamp(t),\n-            (ref Err e) => \"error: \" ~ e.message,\n+                (ref typeof(null) _) => \"null\",\n+                (ref bool b) => b ? \"true\" : \"false\",\n+                (ref long i) => fmtInt(i),\n+                (ref ulong u) => fmtUint(u),\n+                (ref double d) => fmtDouble(d),\n+                (ref string s) => fmtString(s),\n+                (ref immutable(ubyte)[] b) => fmtBytes(b),\n+                (ref List l) => fmtList(l),\n+                (ref Value[string] m) => fmtMap(m),\n+                (ref Entry _) => \"<entry>\",\n+                (ref Duration d) => fmtDuration(d),\n+                (ref SysTime t) => fmtTimestamp(t),\n+                (ref Err e) => \"error: \" ~ e.message,\n         );\n     }\n \n@@ -244,23 +245,26 @@\n \n     /// Format helpers for toString \u2014 defined as statics so dfmt leaves\n     /// the match table above as a clean, scannable list.\n-    private static:\n+private static:\n \n     string fmtInt(long i)\n     {\n         import std.conv : to;\n+\n         return i.to!string;\n     }\n \n     string fmtUint(ulong u)\n     {\n         import std.conv : to;\n+\n         return u.to!string ~ \"u\";\n     }\n \n     string fmtDouble(double d)\n     {\n         import std.conv : to;\n+\n         return d.to!string;\n     }\n \n@@ -272,12 +276,24 @@\n         {\n             switch (c)\n             {\n-                case '\"':  buf ~= `\\\"`; break;\n-                case '\\\\': buf ~= `\\\\`; break;\n-                case '\\n': buf ~= `\\n`; break;\n-                case '\\r': buf ~= `\\r`; break;\n-                case '\\t': buf ~= `\\t`; break;\n-                default:   buf ~= c;    break;\n+            case '\"':\n+                buf ~= `\\\"`;\n+                break;\n+            case '\\\\':\n+                buf ~= `\\\\`;\n+                break;\n+            case '\\n':\n+                buf ~= `\\n`;\n+                break;\n+            case '\\r':\n+                buf ~= `\\r`;\n+                break;\n+            case '\\t':\n+                buf ~= `\\t`;\n+                break;\n+            default:\n+                buf ~= c;\n+                break;\n             }\n         }\n         buf ~= '\"';\n@@ -287,6 +303,7 @@\n     string fmtBytes(immutable(ubyte)[] bytes)\n     {\n         import std.format : format;\n+\n         char[] buf;\n         buf ~= \"b\\\"\";\n         foreach (b; bytes)\n@@ -301,7 +318,8 @@\n         buf ~= '[';\n         foreach (i; 0 .. list.length)\n         {\n-            if (i > 0) buf ~= \", \";\n+            if (i > 0)\n+                buf ~= \", \";\n             buf ~= list.index(i).toString();\n         }\n         buf ~= ']';\n@@ -311,6 +329,7 @@\n     string fmtMap(Value[string] map)\n     {\n         import std.algorithm : sort;\n+\n         char[] buf;\n         buf ~= '{';\n         auto keys = map.keys;\n@@ -318,7 +337,8 @@\n         bool first = true;\n         foreach (k; keys)\n         {\n-            if (!first) buf ~= \", \";\n+            if (!first)\n+                buf ~= \", \";\n             first = false;\n             buf ~= fmtString(k);\n             buf ~= \": \";\n@@ -331,30 +351,37 @@\n     string fmtDuration(Duration d)\n     {\n         import std.format : format;\n+\n         long totalSecs = d.total!\"seconds\";\n         bool negative = totalSecs < 0;\n-        if (negative) totalSecs = -totalSecs;\n+        if (negative)\n+            totalSecs = -totalSecs;\n         long rem = totalSecs;\n         long h = rem / 3600;\n         rem %= 3600;\n         long m = rem / 60;\n         long sec = rem % 60;\n         char[] buf;\n-        if (negative) buf ~= '-';\n+        if (negative)\n+            buf ~= '-';\n         buf ~= \"PT\";\n-        if (h > 0) buf ~= format!\"%dH\"(h);\n-        if (m > 0) buf ~= format!\"%dM\"(m);\n-        if (sec > 0 || (h == 0 && m == 0)) buf ~= format!\"%dS\"(sec);\n+        if (h > 0)\n+            buf ~= format!\"%dH\"(h);\n+        if (m > 0)\n+            buf ~= format!\"%dM\"(m);\n+        if (sec > 0 || (h == 0 && m == 0))\n+            buf ~= format!\"%dS\"(sec);\n         return cast(string) buf;\n     }\n \n     string fmtTimestamp(SysTime st)\n     {\n         import std.format : format;\n+\n         auto utc = st.toUTC();\n         return format!\"%04d-%02d-%02dT%02d:%02d:%02dZ\"(\n-            utc.year, cast(int) utc.month, utc.day,\n-            utc.hour, utc.minute, utc.second);\n+                utc.year, cast(int) utc.month, utc.day,\n+                utc.hour, utc.minute, utc.second);\n     }\n }\n \ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: lazy List subclass:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: list.map() comprehension:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: numeric literals:\ndecel.value.Value: deep equality:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: string methods:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.lexer.Lexer: empty input:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: single = token:\ndecel.lexer.Lexer: string literals:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: null semantics:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.value.Value: toString duration and timestamp:\ndecel.value.Value: toString basics:\ndecel.eval.Eval: string operations:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: timestamp constructor and methods:\ndecel.value.Value: toString collections:\n\nTime taken: 2 ms, 455 \u03bcs, and 2 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "passed": false,
          "side_effects": [
            "files_modified",
            "has_display_output"
          ],
          "success": true,
          "summary": "\u2713 Tests passed (make test)",
          "test_command": "make test"
        },
        {
          "commit": "4b081ae25e69",
          "message": "Committed: 2 file(s) modified/created",
          "side_effects": [
            "mid_turn_commit"
          ],
          "success": true
        }
      ]
    },
    {
      "role": "system",
      "content": "\u2705 Changes committed: e42d01cb",
      "_ui_only": true
    },
    {
      "role": "user",
      "content": "Alright, that's better! Try to move the one-liners back into the match call now that we know the dfmt flag works?"
    },
    {
      "role": "assistant",
      "content": "\n\nThe user wants to inline the simple type handlers back into the `match!` call in `toString()`, removing the separate `fmtInt`, `fmtUint`, `fmtDouble` static helpers (since those are just one-liners). The more complex ones (`fmtString`, `fmtBytes`, `fmtList`, `fmtMap`, `fmtDuration`, `fmtTimestamp`) should stay as separate functions.\n\n<edit file=\"source/decel/value.d\">\n<search>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        auto self = cast(Value) this;\n        return self.inner.match!(\n            (ref typeof(null) _) => \"null\",\n            (ref bool b) => b ? \"true\" : \"false\",\n            (ref long i) => fmtInt(i),\n            (ref ulong u) => fmtUint(u),\n            (ref double d) => fmtDouble(d),\n            (ref string s) => fmtString(s),\n            (ref immutable(ubyte)[] b) => fmtBytes(b),\n            (ref List l) => fmtList(l),\n            (ref Value[string] m) => fmtMap(m),\n            (ref Entry _) => \"<entry>\",\n            (ref Duration d) => fmtDuration(d),\n            (ref SysTime t) => fmtTimestamp(t),\n            (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n</search>\n<replace>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        import std.conv : to;\n        auto self = cast(Value) this;\n        return self.inner.match!(\n            (ref typeof(null) _) => \"null\",\n            (ref bool b) => b ? \"true\" : \"false\",\n            (ref long i) => i.to!string,\n            (ref ulong u) => u.to!string ~ \"u\",\n            (ref double d) => d.to!string,\n            (ref string s) => fmtString(s),\n            (ref immutable(ubyte)[] b) => fmtBytes(b),\n            (ref List l) => fmtList(l),\n            (ref Value[string] m) => fmtMap(m),\n            (ref Entry _) => \"<entry>\",\n            (ref Duration d) => fmtDuration(d),\n            (ref SysTime t) => fmtTimestamp(t),\n            (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n</replace>\n</edit>"
    },
    {
      "role": "user",
      "content": "\u274c `edit` failed:\n\nSearch text not found in source/decel/value.d.\n\n**VERY CLOSE MATCH - check the diff carefully for:\n  \u2022 Trailing whitespace or newlines\n  \u2022 Small typos\n  \u2022 Indentation differences**\n\nFound 96.8% similar text at line 211 (edit distance: 26):\n\n```\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n    ...\n        );\n    }\n```\n\nDiff (--- your search vs +++ actual file):\n```diff\n--- expected\n+++ actual\n@@ -3,18 +3,18 @@\n     {\n         auto self = cast(Value) this;\n         return self.inner.match!(\n-            (ref typeof(null) _) => \"null\",\n-            (ref bool b) => b ? \"true\" : \"false\",\n-            (ref long i) => fmtInt(i),\n-            (ref ulong u) => fmtUint(u),\n-            (ref double d) => fmtDouble(d),\n-            (ref string s) => fmtString(s),\n-            (ref immutable(ubyte)[] b) => fmtBytes(b),\n-            (ref List l) => fmtList(l),\n-            (ref Value[string] m) => fmtMap(m),\n-            (ref Entry _) => \"<entry>\",\n-            (ref Duration d) => fmtDuration(d),\n-            (ref SysTime t) => fmtTimestamp(t),\n-            (ref Err e) => \"error: \" ~ e.message,\n+                (ref typeof(null) _) => \"null\",\n+                (ref bool b) => b ? \"true\" : \"false\",\n+                (ref long i) => fmtInt(i),\n+                (ref ulong u) => fmtUint(u),\n+                (ref double d) => fmtDouble(d),\n+                (ref string s) => fmtString(s),\n+                (ref immutable(ubyte)[] b) => fmtBytes(b),\n+                (ref List l) => fmtList(l),\n+                (ref Value[string] m) => fmtMap(m),\n+                (ref Entry _) => \"<entry>\",\n+                (ref Duration d) => fmtDuration(d),\n+                (ref SysTime t) => fmtTimestamp(t),\n+                (ref Err e) => \"error: \" ~ e.message,\n         );\n     }\n```",
      "_ui_only": true
    },
    {
      "role": "assistant",
      "content": "Ah, dfmt already reformatted the indentation inside the match call. Let me use the correct indentation (16 spaces instead of 12):\n\n<edit file=\"source/decel/value.d\">\n<search>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        auto self = cast(Value) this;\n        return self.inner.match!(\n                (ref typeof(null) _) => \"null\",\n                (ref bool b) => b ? \"true\" : \"false\",\n                (ref long i) => fmtInt(i),\n                (ref ulong u) => fmtUint(u),\n                (ref double d) => fmtDouble(d),\n                (ref string s) => fmtString(s),\n                (ref immutable(ubyte)[] b) => fmtBytes(b),\n                (ref List l) => fmtList(l),\n                (ref Value[string] m) => fmtMap(m),\n                (ref Entry _) => \"<entry>\",\n                (ref Duration d) => fmtDuration(d),\n                (ref SysTime t) => fmtTimestamp(t),\n                (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n</search>\n<replace>\n    /// Human-readable string representation of this Value.\n    string toString() const\n    {\n        import std.conv : to;\n        auto self = cast(Value) this;\n        return self.inner.match!(\n                (ref typeof(null) _) => \"null\",\n                (ref bool b) => b ? \"true\" : \"false\",\n                (ref long i) => i.to!string,\n                (ref ulong u) => u.to!string ~ \"u\",\n                (ref double d) => d.to!string,\n                (ref string s) => fmtString(s),\n                (ref immutable(ubyte)[] b) => fmtBytes(b),\n                (ref List l) => fmtList(l),\n                (ref Value[string] m) => fmtMap(m),\n                (ref Entry _) => \"<entry>\",\n                (ref Duration d) => fmtDuration(d),\n                (ref SysTime t) => fmtTimestamp(t),\n                (ref Err e) => \"error: \" ~ e.message,\n        );\n    }\n</replace>\n</edit>\n\nNow remove the three now-unused static helpers:\n\n<edit file=\"source/decel/value.d\">\n<search>\n    string fmtInt(long i)\n    {\n        import std.conv : to;\n        return i.to!string;\n    }\n\n    string fmtUint(ulong u)\n    {\n        import std.conv : to;\n        return u.to!string ~ \"u\";\n    }\n\n    string fmtDouble(double d)\n    {\n        import std.conv : to;\n        return d.to!string;\n    }\n\n    string fmtString(string s)\n</search>\n<replace>\n    string fmtString(string s)\n</replace>\n</edit>"
    },
    {
      "role": "user",
      "content": "\u274c `edit` failed:\n\nSearch text not found in source/decel/value.d.\n\n**CLOSE MATCH - the text exists but has differences.\nCheck the diff below to see exactly what's different.**\n\nFound 93.7% similar text at line 251 (edit distance: 21):\n\n```\n    string fmtInt(long i)\n    {\n        import std.conv : to;\n    ...\n\n        return d.to!string;\n```\n\nDiff (--- your search vs +++ actual file):\n```diff\n--- expected\n+++ actual\n@@ -1,19 +1,19 @@\n     string fmtInt(long i)\n     {\n         import std.conv : to;\n+\n         return i.to!string;\n     }\n \n     string fmtUint(ulong u)\n     {\n         import std.conv : to;\n+\n         return u.to!string ~ \"u\";\n     }\n \n     string fmtDouble(double d)\n     {\n         import std.conv : to;\n-        return d.to!string;\n-    }\n \n-    string fmtString(string s)+        return d.to!string;\n```",
      "_ui_only": true
    },
    {
      "role": "assistant",
      "content": "The first edit succeeded but dfmt reformatted the file, so the second edit's search text doesn't match. Let me look at the actual current state of the file to get the exact text.",
      "tool_calls": [
        {
          "function": {
            "arguments": "{\"filepath\": \"source/decel/value.d\", \"line\": 245, \"context\": 25}",
            "name": "get_lines"
          },
          "id": "toolu_vrtx_016verAcJo6b29dvEUuu6B8Q",
          "type": "function"
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "toolu_vrtx_016verAcJo6b29dvEUuu6B8Q",
      "content": "{\"content\": \"     220 |                 (ref ulong u) => u.to!string ~ \\\"u\\\",\\n     221 |                 (ref double d) => d.to!string,\\n     222 |                 (ref string s) => fmtString(s),\\n     223 |                 (ref immutable(ubyte)[] b) => fmtBytes(b),\\n     224 |                 (ref List l) => fmtList(l),\\n     225 |                 (ref Value[string] m) => fmtMap(m),\\n     226 |                 (ref Entry _) => \\\"<entry>\\\",\\n     227 |                 (ref Duration d) => fmtDuration(d),\\n     228 |                 (ref SysTime t) => fmtTimestamp(t),\\n     229 |                 (ref Err e) => \\\"error: \\\" ~ e.message,\\n     230 |         );\\n     231 |     }\\n     232 | \\n     233 |     /// Hash support (needed when opEquals is defined).\\n     234 |     size_t toHash() const nothrow @trusted\\n     235 |     {\\n     236 |         try\\n     237 |         {\\n     238 |             auto self = cast(Value) this;\\n     239 |             return hashOf(cast(int) self.type());\\n     240 |         }\\n     241 |         catch (Exception)\\n     242 |         {\\n     243 |             return 0;\\n     244 |         }\\n>>>  245 |     }\\n     246 | \\n     247 |     /// Format helpers for toString \\u2014 defined as statics so dfmt leaves\\n     248 |     /// the match table above as a clean, scannable list.\\n     249 | private static:\\n     250 | \\n     251 |     string fmtInt(long i)\\n     252 |     {\\n     253 |         import std.conv : to;\\n     254 | \\n     255 |         return i.to!string;\\n     256 |     }\\n     257 | \\n     258 |     string fmtUint(ulong u)\\n     259 |     {\\n     260 |         import std.conv : to;\\n     261 | \\n     262 |         return u.to!string ~ \\\"u\\\";\\n     263 |     }\\n     264 | \\n     265 |     string fmtDouble(double d)\\n     266 |     {\\n     267 |         import std.conv : to;\\n     268 | \\n     269 |         return d.to!string;\\n     270 |     }\", \"filepath\": \"source/decel/value.d\", \"range\": \"220-270\", \"side_effects\": [\"ephemeral_result\"], \"success\": true, \"target_line\": 245, \"total_lines\": 613}",
      "_skip_display": true
    },
    {
      "role": "assistant",
      "content": "Now I can see the file's current state. The first edit (inlining the one-liners into the match table) already succeeded. I just need to remove the now-unused `fmtInt`, `fmtUint`, and `fmtDouble` helpers with the correct whitespace (dfmt added blank lines before the return statements):\n\n<edit file=\"source/decel/value.d\">\n<search>\n    string fmtInt(long i)\n    {\n        import std.conv : to;\n\n        return i.to!string;\n    }\n\n    string fmtUint(ulong u)\n    {\n        import std.conv : to;\n\n        return u.to!string ~ \"u\";\n    }\n\n    string fmtDouble(double d)\n    {\n        import std.conv : to;\n\n        return d.to!string;\n    }\n\n    string fmtString(string s)\n</search>\n<replace>\n    string fmtString(string s)\n</replace>\n</edit>\n\n<run_tests/>\n<commit message=\"Inline one-liner fmt helpers (fmtInt, fmtUint, fmtDouble) back into toString match table\n\nNow that dfmt --keep_line_breaks=true preserves the match table layout,\nthe simple one-liners can live inline. The more complex helpers\n(fmtString, fmtBytes, fmtList, fmtMap, fmtDuration, fmtTimestamp)\nremain as private static functions.\"/>\n\nDone! Inlined `fmtInt`, `fmtUint`, and `fmtDouble` back into the `match!` table and removed the now-unused static helpers. The more complex formatters (`fmtString`, `fmtBytes`, `fmtList`, `fmtMap`, `fmtDuration`, `fmtTimestamp`) stay as separate functions since they have real logic.",
      "_inline_results": [
        {
          "message": "Replaced in source/decel/value.d",
          "modified_files": [
            "source/decel/value.d"
          ],
          "side_effects": [
            "files_modified"
          ],
          "success": true
        },
        {
          "display_output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:41:55.660918420 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:41:55.664565531 +0100\n@@ -127,7 +127,9 @@\n             Duration, // duration\n             SysTime, // timestamp\n             Err, // err\n+\n             \n+\n     );\n \n     /// The underlying SumType storage.\n@@ -212,6 +214,7 @@\n     string toString() const\n     {\n         import std.conv : to;\n+\n         auto self = cast(Value) this;\n         return self.inner.match!(\n                 (ref typeof(null) _) => \"null\",\ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: list.map() comprehension:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: null semantics:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: string methods:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: empty input:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: numeric literals:\ndecel.lexer.Lexer: string literals:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.lexer.Lexer: single = token:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.value.Value: deep equality:\ndecel.eval.Eval: string operations:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.value.Value: toString duration and timestamp:\ndecel.value.Value: toString basics:\ndecel.value.Value: toString collections:\ndecel.eval.Eval: lazy List subclass:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: timestamp constructor and methods:\n\nTime taken: 2 ms, 575 \u03bcs, and 2 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "modified_files": [
            "source/decel/value.d"
          ],
          "output": "dfmt reformatted: source/decel/value.d\n--- a/source/decel/value.d\t2026-02-17 14:41:55.660918420 +0100\n+++ b/source/decel/value.d\t2026-02-17 14:41:55.664565531 +0100\n@@ -127,7 +127,9 @@\n             Duration, // duration\n             SysTime, // timestamp\n             Err, // err\n+\n             \n+\n     );\n \n     /// The underlying SumType storage.\n@@ -212,6 +214,7 @@\n     string toString() const\n     {\n         import std.conv : to;\n+\n         auto self = cast(Value) this;\n         return self.inner.match!(\n                 (ref typeof(null) _) => \"null\",\ndecel.context.Context: resolve bindings:\ndecel.eval.Eval: chained comprehensions:\ndecel.eval.Eval: division by zero returns error value:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 non-matching falls through:\ndecel.eval.Eval: context variable lookup:\ndecel.eval.Eval: comparison operators:\ndecel.eval.Eval: float arithmetic:\ndecel.eval.Eval: comprehension with context variables:\ndecel.eval.Eval: .matches() regex method:\ndecel.eval.Eval: Entry.asList() \u2014 entry that acts as a list:\ndecel.eval.Eval: has() macro:\ndecel.eval.Eval: in operator:\ndecel.eval.Eval: in operator with list membership:\ndecel.eval.Eval: duration and timestamp string() cast:\ndecel.eval.Eval: Entry.methodMacro() \u2014 entry-level method macros:\ndecel.eval.Eval: Entry.methodMacro() \u2014 non-matching falls through:\ndecel.eval.Eval: duration constructor and methods:\ndecel.eval.Eval: duration/timestamp from context:\ndecel.eval.Eval: list.exists_one() comprehension:\ndecel.eval.Eval: integer arithmetic:\ndecel.eval.Eval: duration arithmetic:\ndecel.eval.Eval: nested member access:\ndecel.eval.Eval: now() function:\ndecel.eval.Eval: list literals and indexing:\ndecel.eval.Eval: list.all() comprehension:\ndecel.eval.Eval: error propagation:\ndecel.eval.Eval: list.filter() comprehension:\ndecel.eval.Eval: Entry.asValue() \u2014 entry that unwraps to a scalar:\ndecel.eval.Eval: now() rejects arguments:\ndecel.eval.Eval: now() with arithmetic:\ndecel.eval.Eval: list.exists() comprehension:\ndecel.eval.Eval: cross-type numeric comparison:\ndecel.eval.Eval: custom macros:\ndecel.eval.Eval: logical operators:\ndecel.eval.Eval: logical operators reject non-bool operands:\ndecel.eval.Eval: list.map() comprehension:\ndecel.eval.Eval: Entry with both asList() and asValue():\ndecel.eval.Eval: null semantics:\ndecel.eval.Eval: short-circuit evaluation:\ndecel.eval.Eval: syntax error throws:\ndecel.eval.Eval: map literals and access:\ndecel.eval.Eval: type casts:\ndecel.eval.Eval: ternary conditional:\ndecel.eval.Eval: unknown variable from context:\ndecel.lexer.Lexer: comparison and logical operators:\ndecel.eval.Eval: operator precedence:\ndecel.eval.Eval: string methods:\ndecel.lexer.Lexer: escape sequences in strings:\ndecel.lexer.Lexer: empty input:\ndecel.lexer.Lexer: punctuation and grouping:\ndecel.lexer.Lexer: identifiers and keywords:\ndecel.lexer.Lexer: simple arithmetic:\ndecel.lexer.Lexer: numeric literals:\ndecel.lexer.Lexer: string literals:\ndecel.eval.Eval: type() for duration and timestamp:\ndecel.eval.Eval: unary minus:\ndecel.lexer.Lexer: single = token:\ndecel.eval.Eval: timestamp - timestamp \u2192 duration:\ndecel.lexer.Lexer: unary negation and subtraction:\ndecel.value.Value: construct and check types:\ndecel.eval.Eval: ternary rejects non-bool condition:\ndecel.value.Value: deep equality:\ndecel.eval.Eval: string operations:\ndecel.eval.Eval: Entry.evalContinuation() \u2014 Prometheus {attr} filter syntax:\ndecel.value.Value: toString duration and timestamp:\ndecel.value.Value: toString basics:\ndecel.value.Value: toString collections:\ndecel.eval.Eval: lazy List subclass:\ndecel.eval.Eval: timestamp arithmetic:\ndecel.eval.Eval: timestamp constructor and methods:\n\nTime taken: 2 ms, 575 \u03bcs, and 2 hnsecs\n70 test(s) run, 0 failed.\n\nOK!\n\n",
          "passed": false,
          "side_effects": [
            "files_modified",
            "has_display_output"
          ],
          "success": true,
          "summary": "\u2713 Tests passed (make test)",
          "test_command": "make test"
        },
        {
          "commit": "dbe0a0722672",
          "message": "Committed: 1 file(s) modified/created",
          "side_effects": [
            "mid_turn_commit"
          ],
          "success": true
        }
      ]
    }
  ],
  "parent_session": null,
  "child_sessions": [],
  "state": "idle",
  "yield_message": null
}